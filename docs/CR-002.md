**Change Request: CR-002 – SHAP‑Backed Rogue Variable Detection & MPG API for Visualization**

---

## 1. Objective

Extend **CR‑001**’s minimal MPG prototype to:

1. Use a **real prediction model + SHAP** to implement Rogue Variable (RV) detection exactly as in the paper (Shapley contributions, 3‑sigma criterion).  [oai_citation:0‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
2. Map feature‑level Shapley values onto **MPG segments** as structural variables (“variables = segments/pathways”, “Rogue Variables on the MPG” section).  [oai_citation:1‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
3. Expose the resulting RV‑tagged segments via a **small FastAPI service** so any front‑end (Neo4j Browser, Dash, custom React, etc.) can visualize them.

This operationalizes Defs. 5–6 (Rogue Variables via Shapley values and 3σ rule, Eqs. (2–4)) on top of the Layer‑Type Graph and lifted segments from CR‑001.  [oai_citation:2‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 2. Scope

### In scope

- New script: `scripts/mpg_rv_shap_demo.py`
  - Query level‑1 `:Segment` nodes created by CR‑001.
  - Generate a **synthetic decision dataset** where segment metrics influence an outcome.
  - Train a simple **tree model** (RandomForest) with scikit‑learn.
  - Compute **SHAP values**, apply Eq. (3) and Def. 6’s 3σ rule to flag RV segments.  [oai_citation:3‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
  - Update Neo4j: set `rv=true`, `rv_score`, `potency` on `:Segment` nodes.

- New API service: `api/mpg_api.py`
  - FastAPI endpoints to retrieve segments, RV segments, and graph structure.

### Out of scope

- Real LAIZA trial data (we simulate).
- Full Potency Index with all impact factors (RoC, BoI, loops, etc. – here we implement a **simplified potency** based on contribution × centrality).  [oai_citation:4‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Front-end UI code (this CR only provides the API to feed any UI).

---

## 3. Technical design

### 3.1 Prerequisites from CR‑001

We assume CR‑001 is already applied:

- Neo4j has:
  - `:MPGNode` nodes (`level = 0`) and `:Segment` nodes (`level = 1`) with `importance`, `confidence`, `valence`, etc.  [oai_citation:5‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Segments were created using the **Lift operator** from level 0 as described in Defs. 2–4 and illustrated in Fig. 2 (segments as lifted nodes).  [oai_citation:6‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

### 3.2 Structural “variables”

In the paper, **variables** for RV analysis are *structures* (segments, pathways), not raw features.  [oai_citation:7‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

We therefore:

- Treat each level‑1 `:Segment` as a variable `x_k`.
- Define one **numeric feature per segment** in our model:  
  `f_k = g(importance, confidence, valence, noise)` for that segment.
- Train `f(x) ≈ P(y | x)` where `y` is a synthetic outcome.
- Use SHAP to get ψₖ(x) per segment, then set `sₖ(x) = |ψₖ(x)|` as in Eq. (3).  [oai_citation:8‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

### 3.3 Rogue Variable criterion

For a given instance x:

- Let `s_k = |ψ_k(x)|` (absolute Shapley contribution per segment).
- Compute  
  `s̄ = mean_k s_k`, `σ̂ = std_k s_k`.  
- Segment k is a **Rogue Variable** if:

```text
s_k ≥ s̄ + 3 σ̂      (Def. 6)
```

We mark such segments in Neo4j:

- `rv = true`
- `rv_score = s_k`
- `potency = simple_potency(s_k, importance, confidence)`

---

## 4. Implementation: `scripts/mpg_rv_shap_demo.py`

Below is a self‑contained Python script that:

1. Connects to Neo4j (reuses the `MPGNeo4j` class structure from CR‑001, but adds a few methods).  
2. Builds a synthetic dataset from existing segments.  
3. Trains a tree model, computes SHAP, and flags Rogue segments.

```python
"""
mpg_rv_shap_demo.py

CR-002: SHAP-backed Rogue Variable detection on MPG Segments.

Prereqs:
- CR-001 ran successfully, so we have level-1 :Segment nodes with demo=true.
"""

from dataclasses import dataclass
from typing import List, Dict, Tuple
import uuid
import math
import statistics

import numpy as np
import pandas as pd
from neo4j import GraphDatabase
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import shap


# === CONFIG ===

NEO4J_URI = "bolt://localhost:7687"
NEO4J_USER = "neo4j"
NEO4J_PASSWORD = "password"   # <-- set for your env

N_SAMPLES = 500   # synthetic trials


# === NEO4J CLIENT (minimal subset from CR-001) ===

class MPGNeo4j:
    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def run(self, query: str, **params):
        with self.driver.session() as session:
            return list(session.run(query, **params))

    def get_demo_segments(self):
        q = """
        MATCH (s:Segment)
        WHERE s.demo = true
        RETURN s.id AS id,
               coalesce(s.importance, 0.5) AS importance,
               coalesce(s.confidence, 0.5) AS confidence,
               coalesce(s.valence, 0.0) AS valence
        """
        return self.run(q)

    def mark_segment_as_rv(self, seg_id: str, rv_score: float, potency: float):
        q = """
        MATCH (s:Segment {id: $id})
        SET s.rv = true,
            s.rv_score = $rv_score,
            s.potency = $potency
        """
        self.run(q, id=seg_id, rv_score=float(rv_score), potency=float(potency))

    def clear_rv_flags(self):
        q = """
        MATCH (s:Segment)
        WHERE s.demo = true
        REMOVE s.rv, s.rv_score, s.potency
        """
        self.run(q)


# === SYNTHETIC DATA GENERATION ===

def build_segment_feature_matrix(db: MPGNeo4j, n_samples: int = N_SAMPLES):
    """
    Build a synthetic dataset where each feature corresponds to one segment.

    Feature for segment k (per sample) is:
        f_k = base_k + eps, where
        base_k = 0.5*importance + 0.3*confidence + 0.2*max(valence, 0)
    Outcome y is a logistic function of a few "true driver" segments + noise.
    """
    records = db.get_demo_segments()
    if len(records) == 0:
        raise RuntimeError("No demo segments found. Run CR-001 first.")

    seg_ids = [r["id"] for r in records]
    importance = {r["id"]: float(r["importance"]) for r in records}
    confidence = {r["id"]: float(r["confidence"]) for r in records}
    valence = {r["id"]: float(r["valence"]) for r in records}

    # Choose a small subset of segments as ground-truth drivers
    rng = np.random.default_rng(42)
    driver_ids = rng.choice(seg_ids, size=min(3, len(seg_ids)), replace=False)
    print("Ground-truth driver segments (for synthetic label):")
    for d in driver_ids:
        print("  ", d)

    X = np.zeros((n_samples, len(seg_ids)))
    columns = []
    for j, seg_id in enumerate(seg_ids):
        feat_name = f"seg_{seg_id}"
        columns.append(feat_name)
        base = (
            0.5 * importance[seg_id]
            + 0.3 * confidence[seg_id]
            + 0.2 * max(valence[seg_id], 0.0)
        )
        # Same base_k across all samples; add i.i.d. noise per sample
        X[:, j] = base + rng.normal(0, 0.05, size=n_samples)

    # Generate labels y from logistic of subset of features (+ noise)
    w = np.zeros(len(seg_ids))
    for j, seg_id in enumerate(seg_ids):
        if seg_id in driver_ids:
            # give drivers positive weight
            w[j] = rng.uniform(1.0, 2.0)
        else:
            w[j] = rng.uniform(-0.2, 0.2)

    logits = X.dot(w) + rng.normal(0, 0.5, size=n_samples)
    probs = 1 / (1 + np.exp(-logits))
    y = (probs > 0.5).astype(int)

    df = pd.DataFrame(X, columns=columns)
    df["y"] = y
    return df, seg_ids


# === SHAP-BASED RV DETECTION ===

def simple_potency(rv_score: float, importance: float, confidence: float) -> float:
    """
    Simplified Potency Index:
        potency = rv_score * (0.5 * importance + 0.5 * confidence)
    In the full framework, this would incorporate rate-of-change, breadth-of-impact,
    loops, affective load, gate leverage, robustness, etc. (section 4.2).
    """
    return float(rv_score * (0.5 * importance + 0.5 * confidence))


def shap_rv_detection(db: MPGNeo4j, df: pd.DataFrame, seg_ids: List[str]):
    """
    Train a tree model, compute SHAP values, and mark Rogue segments
    by the 3-sigma rule from the paper (Def. 6, Eq. (4)).
    """
    feature_cols = [c for c in df.columns if c.startswith("seg_")]
    X = df[feature_cols].values
    y = df["y"].values

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.3, random_state=42, stratify=y
    )

    model = RandomForestClassifier(
        n_estimators=200,
        max_depth=None,
        random_state=42,
        n_jobs=-1
    )
    model.fit(X_train, y_train)
    print("Train accuracy:", model.score(X_train, y_train))
    print("Test accuracy :", model.score(X_test, y_test))

    explainer = shap.TreeExplainer(model)
    shap_values = explainer.shap_values(X_test)

    # For binary classification, shap_values is [class0, class1]; use positive class
    if isinstance(shap_values, list) and len(shap_values) == 2:
        sv = shap_values[1]
    else:
        sv = shap_values  # fallback

    # We'll use the first test instance for RV detection demo
    instance_sv = sv[0]
    abs_contrib = np.abs(instance_sv)

    # Eq. (3): mean and std of |ψ_k(x)|
    mean_s = float(abs_contrib.mean())
    std_s = float(abs_contrib.std(ddof=1) if abs_contrib.size > 1 else 0.0)
    threshold = mean_s + 3 * std_s

    print(f"RV threshold (mean + 3σ) = {threshold:.6f}")

    # Map feature index -> segment id
    feature_to_seg = {}
    for j, col in enumerate(feature_cols):
        seg_id = col[len("seg_") :]
        feature_to_seg[j] = seg_id

    # Clear previous RV flags
    db.clear_rv_flags()

    # Find features above threshold and mark segments as RV in Neo4j
    for j, contrib in enumerate(abs_contrib):
        if contrib >= threshold:
            seg_id = feature_to_seg[j]
            # Lookup importance/confidence from DB for potency calc
            recs = db.run(
                """
                MATCH (s:Segment {id: $id})
                RETURN coalesce(s.importance, 0.5) AS importance,
                       coalesce(s.confidence, 0.5) AS confidence
                """,
                id=seg_id,
            )
            if not recs:
                continue
            imp = float(recs[0]["importance"])
            conf = float(recs[0]["confidence"])
            potency = simple_potency(contrib, imp, conf)
            db.mark_segment_as_rv(seg_id, rv_score=float(contrib), potency=potency)
            print(
                f"Segment {seg_id} marked as RV | "
                f"contribution={contrib:.6f}, importance={imp:.3f}, "
                f"confidence={conf:.3f}, potency={potency:.6f}"
            )


# === MAIN ===

def main():
    db = MPGNeo4j(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)
    try:
        df, seg_ids = build_segment_feature_matrix(db, n_samples=N_SAMPLES)
        shap_rv_detection(db, df, seg_ids)
        print("SHAP-based RV detection done.")
    finally:
        db.close()


if __name__ == "__main__":
    main()
```

### How this aligns with the paper

- Uses Shapley contributions ψₖ(x) to measure **marginal loss reduction**, then **absolute contributions** `s_k = |ψ_k|` and the three‑sigma RV definition (Eqs. 2–4, Def. 6).  [oai_citation:9‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Treats **segments as variables** (not raw features), per “Rogue Variables on the MPG” section, where variables are structural patterns: segments and pathways.  [oai_citation:10‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 5. Implementation: `api/mpg_api.py` (FastAPI)

This API exposes the MPG + RV annotations so you can plug in any visualization you like.

```python
"""
mpg_api.py

Simple FastAPI service exposing MPG segments and Rogue Variables.
"""

from typing import List, Dict, Any
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from neo4j import GraphDatabase


NEO4J_URI = "bolt://localhost:7687"
NEO4J_USER = "neo4j"
NEO4J_PASSWORD = "password"


class MPGNeo4j:
    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def run(self, query: str, **params):
        with self.driver.session() as session:
            return list(session.run(query, **params))

    def get_segments(self) -> List[Dict[str, Any]]:
        q = """
        MATCH (s:Segment)
        WHERE s.demo = true
        RETURN s
        """
        records = self.run(q)
        return [dict(record["s"]) for record in records]

    def get_rv_segments(self) -> List[Dict[str, Any]]:
        q = """
        MATCH (s:Segment)
        WHERE s.demo = true AND coalesce(s.rv, false) = true
        RETURN s
        """
        records = self.run(q)
        return [dict(record["s"]) for record in records]

    def get_segment_edges(self) -> List[Dict[str, Any]]:
        q = """
        MATCH (s:Segment)-[r]->(t:Segment)
        WHERE s.demo = true AND t.demo = true
        RETURN s.id AS src, t.id AS dst, type(r) AS type, r.strength AS strength
        """
        return [dict(r) for r in self.run(q)]


db = MPGNeo4j(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)

app = FastAPI(title="H3LIX MPG API (CR-002)")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # tighten in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("shutdown")
def shutdown_event():
    db.close()


@app.get("/segments")
def list_segments():
    """
    All level-1 segments (demo).
    """
    return db.get_segments()


@app.get("/segments/rv")
def list_rv_segments():
    """
    Segments currently marked as Rogue Variables.
    """
    return db.get_rv_segments()


@app.get("/segments/edges")
def list_segment_edges():
    """
    Directed edges between segments.
    """
    return db.get_segment_edges()
```

Run it:

```bash
uvicorn api.mpg_api:app --reload
```

Now you can:

- `GET /segments` – all segments (with `rv`, `rv_score`, `potency` if present).  
- `GET /segments/rv` – only segments marked as Rogue Variables.  
- `GET /segments/edges` – inter‑segment edges, useful to draw lifted graph like *Fig. 2* and highlight RV nodes.  [oai_citation:11‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 6. How to run CR‑002 end‑to‑end

1. **Run CR‑001** at least once (to seed level‑0 graph and lift level‑1 segments).  
2. Run SHAP RV pipeline:

   ```bash
   python scripts/mpg_rv_shap_demo.py
   ```

   - This will:
     - Generate a synthetic dataset.
     - Train a RandomForest.
     - Compute SHAP values for one test instance.
     - Mark any 3σ‑outlier segments as `rv=true` in Neo4j.

3. Start API:

   ```bash
   uvicorn api.mpg_api:app --reload
   ```

4. Inspect in Neo4j Browser:

   ```cypher
   MATCH (s:Segment {demo: true}) RETURN s;
   MATCH (s:Segment {rv: true}) RETURN s;
   ```

   You should see some segments with `rv = true`, `rv_score`, and `potency`.

5. (Optional) Hook up any graph UI (D3, vis.js, Dash, Neo4j Bloom) to `/segments` and `/segments/edges` to visualize segments and highlight RV nodes.

---

## 7. Acceptance criteria

CR‑002 is complete when:

1. **SHAP-backed RV detection**
   - `mpg_rv_shap_demo.py` runs without errors and prints:
     - model train/test accuracy
     - RV threshold (mean + 3σ)
     - a list of segments flagged as RVs with their contributions and potency.  
   - In Neo4j, `:Segment` nodes exist with:
     - `rv = true` for at least one segment
     - `rv_score` and `potency` set numerically.

2. **Theoretical alignment**
   - The implementation:
     - Uses Shapley contributions ψₖ(x), absolute contributions sₖ(x), mean s̄(x), and std σ̂(x) as per Eqs. (2–4).  [oai_citation:12‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
     - Applies the three‑sigma criterion in Def. 6.
     - Treats **segments as variables**, consistent with “Rogue Variables on the MPG” (segments and inter‑level pathways as primary candidates).  [oai_citation:13‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

3. **API availability**
   - FastAPI server runs and returns:
     - `/segments` → JSON list of segments with metrics and RV flags.
     - `/segments/rv` → subset with `rv=true`.
     - `/segments/edges` → adjacency info for level‑1 graph.

4. **Docs**
   - CR‑002 document (this text) is stored (e.g. `docs/CR-002-RV-SHAP-and-API.md`) alongside the scripts.

---

If you’d like CR‑003 next, we can focus on **temporal updates + Potency Index**: track RV segments over time, compute impact factors (RoC, BoI, loops, affective load, gate leverage, robustness) and write a more complete Potency Index back into Neo4j as described in the “Impact Factors for Structural Rogue Variables” section.  [oai_citation:14‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)
