**Change Request: CR‑006 – Multi‑Participant / Collective MPG, Cross‑Participant Echoes & Group Coherence**

---

## 1. Objective

Extend CR‑001–CR‑005 from single‑person cognition to **collective / multi‑participant** settings by:

1. Representing **multiple individual MPGs** in Neo4j and linking them via **cross‑participant echoes** (similar segments, pathways, and Rogue structures).  
2. Building a **Collective MPG** that aggregates shared structures into group‑level segments and meta‑segments.  
3. Computing **group‑level Noetic coherence** and RV Potency so you can study and control **collective states** (e.g., team intuition, group lock‑in, shared blind spots).  [oai_citation:0‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
4. Providing experiments & APIs to compare:
   - Individual vs group coherence.
   - Individual MUFS / MPG‑Intuition vs group‑level MUFS / intuition.

This implements the “scaling the experimental program to collaborative settings (multi‑agent MPG echoes)” direction flagged in the paper’s conclusion.  [oai_citation:1‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 2. Scope

### In scope

- Neo4j schema extensions for:
  - `:Group`, `:GroupSession`, `:GroupTrial`.
  - Cross‑participant echo relationships.
  - Collective segments / Collective MPG.
- Python scripts:
  - **`collective_mpg_build.py`** – detect cross‑participant echoes and construct a Collective MPG.  
  - **`collective_coherence.py`** – compute group coherence & group RV/Potency from multiple participants’ SegmentStates.  
- API endpoints to query:
  - Group‑level segments & RVs.
  - Group coherence time‑series.
  - Links between individual MUFS / MPG‑Intuition and group‑level patterns.

### Out of scope

- Actual multi‑user front‑end (shared task UI, chat, etc.).
- Advanced consensus modeling (e.g., game‑theoretic group decision rules) – we keep it simple: majority vote / weighted aggregation.

---

## 3. Theoretical grounding (how this fits the paper)

- MPG already supports **hierarchical, multi‑scale structure** and echoes across levels: nodes → segments → meta‑segments.  [oai_citation:2‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- The **dynamics** section defines MPG as a time‑indexed hierarchy MPGₜ, with updates that localize → roll up → restructure → project down.  [oai_citation:3‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Rogue Variable analysis explicitly mentions **segments and inter‑level pathways** as structural units, with Potency used for prioritization and governance.  [oai_citation:4‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- The conclusion explicitly calls out **“scaling the experimental program to collaborative settings (multi‑agent MPG echoes)”** as a next step.  [oai_citation:5‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

CR‑006 treats each participant as its own MPG, then adds:

- **echo detection** across MPGs (similar constructs in different people),
- a **Collective MPG** (meta‑graph of shared segments),
- and **group‑level coherence / RV analysis**.

---

## 4. Schema extensions (Neo4j)

### 4.1 Group entities

New labels:

- `:Group` – a team / cohort / experimental group.
- `:GroupSession` – a multi‑participant session (e.g., team task).
- `:GroupTrial` – group‑level view of a shared trial (e.g., same item for all participants at a given time).
- `:CollectiveSegment` – segment in the Collective MPG.

Constraints:

```cypher
CREATE CONSTRAINT group_id IF NOT EXISTS
FOR (g:Group) REQUIRE g.id IS UNIQUE;

CREATE CONSTRAINT groupsession_id IF NOT EXISTS
FOR (gs:GroupSession) REQUIRE gs.id IS UNIQUE;

CREATE CONSTRAINT grouptrial_id IF NOT EXISTS
FOR (gt:GroupTrial) REQUIRE gt.id IS UNIQUE;

CREATE CONSTRAINT collective_segment_id IF NOT EXISTS
FOR (cs:CollectiveSegment) REQUIRE cs.id IS UNIQUE;
```

Relationships:

```cypher
// Group structure
(:Group)-[:HAS_GROUP_SESSION]->(:GroupSession)
(:GroupSession)-[:HAS_GROUP_TRIAL]->(:GroupTrial)

// link individual sessions/trials to group
(:GroupSession)-[:INCLUDES_SESSION]->(:Session)
(:GroupTrial)-[:ALIGNES_TRIAL]->(:Trial)

// link group to collective segments
(:Group)-[:HAS_COLLECTIVE_SEGMENT]->(:CollectiveSegment)
```

### 4.2 Cross‑participant echoes

We need to express that **node/segment A in person P** is structurally/semantically similar to **node/segment B in person Q**.

New relationships:

- `(:MPGNode)-[:ECHO_NODE]->(:MPGNode)`
- `(:Segment)-[:ECHO_SEGMENT]->(:Segment)`

Properties:

- `similarity: float` in [0,1]
- `basis: string` (e.g. `"embedding"`, `"structure"`, `"semantic"`)
- `demo: bool` for our prototypes.

We will build `ECHO_SEGMENT` based on:

- semantic / textual similarity of node labels & evidence,
- structural metrics (density, motifs) as described in the topology & geometry section.  [oai_citation:6‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

### 4.3 Collective segments

`CollectiveSegment` nodes represent **clusters of echoed segments** across participants:

Properties:

```text
id: string
name: string

member_segment_ids: [string]   # individual Segment.id list
participant_ids: [string]

valence: float          # group average
intensity: float        # group average
cohesion: float         # how similar members are
potency: float          # collective Potency (group RV)
confidence: float       # rolled-up confidence
level: int              # meta-level (e.g., 2+)

rv: bool                # group-level RV flag
rv_score: float         # group-level Shapley/importance
```

Relationships:

- `(:CollectiveSegment)-[:AGGREGATES]->(:Segment)`
- `(:CollectiveSegment)-[:CAUSES/TRIGGERS/...]->(:CollectiveSegment)` for collective pathways.

---

## 5. Algorithms & scripts

### 5.1 Cross‑participant echo detection (`collective_mpg_build.py` – part 1)

Goal: **cluster similar segments across different participants**.

Steps:

1. Build a per‑segment embedding:
   - Combine:
     - textual info (name, reasoning, evidence snippets),
     - structural metrics (importance, confidence, centrality, level, motifs).  [oai_citation:7‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
   - Feed into an embedding model (e.g., SBERT) → vector `v_seg`.

2. Store embedding in Neo4j (or external store keyed by `Segment.id`).

3. For each segment pair (s_i, s_j) from **different participants**:
   - Compute cosine similarity `sim = cos(v_i, v_j)`.
   - If `sim ≥ sim_threshold`, create `(:Segment)-[:ECHO_SEGMENT {similarity: sim}]->(:Segment)`.

4. Build a similarity graph on segments:
   - Nodes = segments.
   - Edges = `ECHO_SEGMENT` with weight `similarity`.
   - Run community detection (e.g., Louvain) to get **cross‑participant clusters**.

5. For each cluster with at least `min_participants`:
   - Create `:CollectiveSegment` node.
   - Set `member_segment_ids`, `participant_ids`.
   - Aggregate metrics:

     ```python
     valence = mean(segment.valence)
     intensity = mean(segment.intensity)
     confidence = mean(segment.confidence)
     cohesion = average pairwise similarity within cluster
     ```

   - Link `CollectiveSegment` → individual segments with `:AGGREGATES`.

Pseudo‑sketch:

```python
def build_collective_segments(db, sim_threshold=0.7, min_participants=2):
    segs = load_segments_and_embeddings(db)  # {id: (participant_id, vec, props)}

    # Build similarity graph and clusters (using networkx + community)
    # ...

    for cluster in clusters:
        participants = {segs[sid].participant_id for sid in cluster}
        if len(participants) < min_participants:
            continue

        agg_props = aggregate_props([segs[sid].props for sid in cluster])
        cs_id = create_collective_segment(db, cluster, participants, agg_props)
        for sid in cluster:
            create_aggregates_edge(db, cs_id, sid)
```

### 5.2 Collective MPG edges (part 2)

We need **group‑level pathways**:

- For each pair of `CollectiveSegment` nodes (CS_A, CS_B):
  - Look at all edges between member segments of A and member segments of B.
  - Aggregate direction, strength, and type (like Lift operator):  [oai_citation:8‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

    ```text
    strength_group = mean(strength_ij)
    confidence_group = mean(confidence_ij)
    ```

  - Create edges:

    ```cypher
    (csA)-[:CAUSES {strength: strength_group, confidence: confidence_group}]->(csB)
    ```

Now you have a **Collective MPG**: `G_collective = {CollectiveSegments, their edges}`.

### 5.3 Group RV & Potency (`collective_coherence.py`)

Analogous to CR‑002/003, but on **CollectiveSegments**:

1. Build dataset rows **per GroupTrial**:

   - Features:
     - For each CollectiveSegment, e.g. activation/value for this trial:
       - average of member SegmentState.rv_score, potency, etc. across participants.
     - Group‑level somatic features: aggregated HRV, EDA across participants.
     - Group‑level symbolic features: entropy of group belief/consensus.

2. Train a model `f_group(x) → y_group` (e.g., correct team decision, group reward).

3. Use SHAP to get ψₖ(x) for each **CollectiveSegment feature**.  [oai_citation:9‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

4. Apply 3‑sigma RV rule (Def. 6) to flag **collective RVs** (segments/pathways whose group‑level contribution is unusually large).  [oai_citation:10‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

5. Compute **group Potency** using the same Impact Factors but:

   - RoC: change in group‐level rv_score over GroupSessions.
   - BoI: number of GroupTrials and outcome metrics the collective segment touches.
   - Amplification: loops in the Collective MPG (group pathways).
   - Affective load: average emotional load of member segments across participants.
   - Gate leverage: number of boundary CollectiveSegments used as “gates” to other structures.
   - Robustness: consistency across sessions and tasks (plus evidence quality).  [oai_citation:11‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

6. Write:

   - `CollectiveSegment.rv`, `CollectiveSegment.rv_score`, `CollectiveSegment.potency`.
   - Optionally, `CollectiveSegmentState` analog to `SegmentState` if you want temporal snapshots.

---

## 6. Group Noetic coherence

### 6.1 Group coherence metrics

Extend CR‑003’s Noetic metrics to **multi‑participant**:

For each GroupTrial / time window:

1. Gather:

   - Per‑participant coherence `C_i(t)` (from Noetic layer).  [oai_citation:12‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
   - Key somatic features per participant (heart rate, HRV, EDA, pupil).
   - Key symbolic features per participant (entropy of belief state, prediction error).
   - Group‐level alignment measures:
     - agreement in choice,
     - variance in confidence.

2. Compute:

   - **Cross‑participant correlation matrices**: correlations between participants’ somatic and symbolic markers.
   - **Group entropy metrics**: e.g., entropy of decision distribution, coherence of textual narratives.
   - **Multi‑participant coherence spectra**: cross‑wavelet / phase coherence between participants’ somatic signals (e.g., shared rhythms during synchronized states).  [oai_citation:13‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

3. Define a **group coherence score** `C_group(t)`:

   ```text
   C_group = f(mean_i C_i, mean cross-participant correlations, 1 - group_entropy)
   ```

   Normalize to 0..1 and store on `GroupTrial` (and/or `CollectiveSegmentState`).

### 6.2 Mirror Core integration

The Mirror Core can then:

- Adjust **group‑level policies** based on `C_group(t)`:
  - e.g., when group coherence is low but a high‑potency collective RV is active, recommend extra deliberation / re‑framing.
- Interrogate **collective MUFS**:
  - Are there GroupTrials where re‑introducing specific CollectiveSegments flips the **group decision**?

---

## 7. API extensions

Extend your FastAPI service with **group endpoints**:

```python
# api/collective_api.py
from fastapi import APIRouter

router = APIRouter(prefix="/collective", tags=["collective"])

@router.get("/segments")
def list_collective_segments():
    # RETURN all CollectiveSegment nodes and their basic metrics
    ...

@router.get("/segments/rv")
def list_collective_rvs():
    # RETURN CollectiveSegments with rv = true
    ...

@router.get("/coherence/{group_session_id}")
def group_coherence_series(group_session_id: str):
    # RETURN time series of C_group(t) for the session
    ...

@router.get("/trials/{group_trial_id}")
def group_trial_detail(group_trial_id: str):
    # RETURN group decision, per-participant decisions,
    # MUFS incidence, C_group, active collective RVs, etc.
    ...
```

Front‑ends can use this to display:

- Group MPG graph (CollectiveSegments + edges).  
- Heatmaps of group coherence.  
- Overlays of collective RVs and Potency.

---

## 8. Collective experiments (what to run)

Build on Sec. 6’s experimental strategy, but now at **group level**:  [oai_citation:14‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

1. **Group decision task** (e.g., joint classification, negotiation, planning):
   - Participants discuss or respond individually; group decision is majority or consensus.

2. Run **Full vs Restricted** blocks:
   - Full: system uses all participants’ MPGs and full inputs.  
   - Restricted: IU (mask subtle cues) and/or PU (ablated CollectiveSegments guided by Potency).

3. Measure:

   - MUFS incidence at **individual** and **group** levels.
   - Alignment between:
     - individual MPG‑Intuition labels and group decisions,
     - group coherence `C_group` and performance (accuracy, calibration).
   - Do **high group coherence episodes** coincide with:
     - more collective MUFS,
     - better group decisions under restricted conditions?

This directly probes whether **collective “intuition”** (high group coherence + nonempty group MUFS) preserves or improves decision quality when deliberation is constrained—mirroring the single‑person predictions in the paper.  [oai_citation:15‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 9. Acceptance criteria

CR‑006 is complete when:

1. **Schema & data model**
   - Neo4j includes `:Group`, `:GroupSession`, `:GroupTrial`, and `:CollectiveSegment` nodes with appropriate constraints and relationships.
   - Cross‑participant `ECHO_SEGMENT` relationships exist with similarity scores.

2. **Collective MPG**
   - `collective_mpg_build.py` builds CollectiveSegments from echoed segments across ≥2 participants and constructs edges between them (Collective MPG).
   - Each CollectiveSegment stores aggregated metrics (valence, confidence, cohesion, participant_ids).

3. **Group RV & Potency**
   - `collective_coherence.py` (or equivalent) trains a group‑level model, computes SHAP contributions for CollectiveSegments, and marks some as `rv = true` with `rv_score` and `potency`.
   - Potency incorporates group‑level versions of the Impact Factors defined in the paper (RoC, BoI, Amplification, Affective load, Gate leverage, Robustness).  [oai_citation:16‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

4. **Group coherence**
   - For each GroupTrial, a `C_group` coherence score is computed and stored.
   - You can query and visualize `C_group` over time for each GroupSession.

5. **API**
   - Endpoints `/collective/segments`, `/collective/segments/rv`, `/collective/coherence/{group_session_id}`, `/collective/trials/{group_trial_id}` are implemented and return reasonable data.

6. **Experiment readiness**
   - A basic collective experiment can be run where:
     - multiple participants act on the same tasks,
     - individual MPGs, MUFS, and MPG‑Intuition markers are recorded (CR‑005),
     - group‑level structures (CollectiveSegments, C_group, collective RVs) are computed,
     - analysis scripts can correlate group coherence, MUFS, and decision quality.

---

If you’d like a **CR‑007**, a natural next step is **policy learning over Collective MPG**: letting the system learn group‑level interventions (who to nudge, which RV to address, what information to surface) to actively improve group coherence and performance while keeping all changes auditable and aligned with the governance principles in the RV section.  [oai_citation:17‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)
