Hereâ€™s **CRâ€‘303** ðŸ˜Š

---

## CRâ€‘303 â€“ Implement Shared Schemas & Example Viewer Wiring

**Status:** Proposed  
**Type:** Implementation / API  
**Baseline:**  
- CRâ€‘301 â€“ Canonical telemetry message schemas  
- CRâ€‘302 â€“ Visualizationâ€‘facing API (snapshot / replay / stream / MPG & decision queries)  
- Minimum Viable Stack (FastAPI + TimescaleDB + Neo4j + React/R3F + WebSockets)  [oai_citation:0â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_00000000a2f071f4a36d5a4040b12b83)  

This CR turns the abstract contracts into **concrete Python + TypeScript modules** and a **minimal example viewer flow**.

---

## 1. Goals

1. Implement **Pydantic models** matching CRâ€‘301 payloads and CRâ€‘302 responses.
2. Generate or mirror **TypeScript types** from those models for the React/R3F client.
3. Provide small, workingâ€‘style examples:
   - FastAPI router using those models.
   - Frontend API client (REST + WebSocket).
   - Tiny state store + scene stub that consumes live data.

---

## 2. Backend: Pydantic Schemas

### 2.1 File layout

Add a new package:

```text
backend/app/schemas/
  __init__.py
  telemetry.py
  api.py
```

---

### 2.2 `telemetry.py`

```python
# backend/app/schemas/telemetry.py
from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, Generic, List, Optional, Tuple, TypeVar

from pydantic import BaseModel, Field
from typing_extensions import Literal


# --- enums ------------------------------------------------------------------


class MessageType(str, Enum):
    SOMATIC_STATE = "somatic_state"
    SYMBOLIC_STATE = "symbolic_state"
    NOETIC_STATE = "noetic_state"
    DECISION_CYCLE = "decision_cycle"
    MPG_DELTA = "mpg_delta"
    ROGUE_VARIABLE_EVENT = "rogue_variable_event"
    MUFS_EVENT = "mufs_event"


class SourceLayer(str, Enum):
    SOMATIC = "Somatic"
    SYMBOLIC = "Symbolic"
    NOETIC = "Noetic"
    MIRROR_CORE = "MirrorCore"
    MPG = "MPG"


class StreamName(str, Enum):
    SOMATIC = "somatic"
    SYMBOLIC = "symbolic"
    BEHAVIORAL = "behavioral"
    EXTERNAL = "external"


class UnawarenessType(str, Enum):
    INPUT = "IU"
    PROCESS = "PU"


# --- payload models ---------------------------------------------------------


class SomaticAnticipatoryMarker(BaseModel):
    marker_type: Literal["readiness_like", "phase_locking", "other"]
    lead_time_ms: int
    confidence: float = Field(ge=0.0, le=1.0)


class SomaticStatePayload(BaseModel):
    t_rel_ms: int
    window_ms: int
    features: Dict[str, float]
    innovation: Optional[Dict[str, float]] = None
    covariance_diag: Optional[Dict[str, float]] = None
    global_uncertainty_score: Optional[float] = Field(
        default=None, ge=0.0, le=1.0
    )
    change_point: bool = False
    anomaly_score: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    anticipatory_markers: List[SomaticAnticipatoryMarker] = Field(default_factory=list)


class SymbolicBelief(BaseModel):
    id: str
    kind: Literal["entity", "event", "relation", "policy"]
    label: str
    description: Optional[str] = None
    valence: Optional[float] = Field(default=None, ge=-1.0, le=1.0)
    intensity: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    recency: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    stability: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    confidence: float = Field(ge=0.0, le=1.0)  # Conf(v)
    importance: float = Field(ge=0.0, le=1.0)  # Imp(v)


class SymbolicPredictionOption(BaseModel):
    value: str
    probability: float = Field(ge=0.0, le=1.0)


class SymbolicPrediction(BaseModel):
    id: str
    target_type: Literal["word", "event", "outcome"]
    horizon_ms: Optional[int] = None
    topk: List[SymbolicPredictionOption]
    brier_score: Optional[float] = None
    realized_value: Optional[str] = None
    realized_error: Optional[float] = None


class SymbolicUncertaintyRegion(BaseModel):
    label: str
    belief_ids: List[str]
    comment: Optional[str] = None


class SymbolicStatePayload(BaseModel):
    t_rel_ms: int
    belief_revision_id: str
    beliefs: List[SymbolicBelief]
    predictions: List[SymbolicPrediction] = Field(default_factory=list)
    uncertainty_regions: List[SymbolicUncertaintyRegion] = Field(default_factory=list)


class NoeticStreamCorrelation(BaseModel):
    stream_x: StreamName
    stream_y: StreamName
    r: float = Field(ge=-1.0, le=1.0)


class NoeticSpectrumBand(BaseModel):
    band_label: str
    freq_range_hz: Tuple[float, float]
    coherence_strength: float = Field(ge=0.0, le=1.0)


class NoeticIntuitiveAccuracyEstimate(BaseModel):
    p_better_than_baseline: float = Field(ge=0.0, le=1.0)
    calibration_error: Optional[float] = None


class NoeticStatePayload(BaseModel):
    t_rel_ms: int
    window_ms: int
    global_coherence_score: float = Field(ge=0.0, le=1.0)
    entropy_change: float
    stream_correlations: List[NoeticStreamCorrelation]
    coherence_spectrum: List[NoeticSpectrumBand]
    intuitive_accuracy_estimate: Optional[NoeticIntuitiveAccuracyEstimate] = None


class DecisionAction(BaseModel):
    action_id: str
    label: str
    params: Optional[Dict[str, Any]] = None


class DecisionOutcome(BaseModel):
    label: str
    metrics: Dict[str, float]


class NoeticAdjustment(BaseModel):
    attention_gain: Optional[float] = None
    decision_threshold_delta: Optional[float] = None
    learning_rate_delta: Optional[float] = None


class DecisionCyclePayload(BaseModel):
    sork_cycle_id: str
    decision_id: Optional[str] = None
    phase: Literal["S", "O", "R", "K", "N", "S_prime"]
    phase_started_utc: datetime
    phase_ended_utc: Optional[datetime] = None

    stimulus_refs: Optional[List[Dict[str, str]]] = None
    organism_belief_ids: Optional[List[str]] = None
    response_action: Optional[DecisionAction] = None
    consequence_outcome: Optional[DecisionOutcome] = None
    noetic_adjustments: Optional[NoeticAdjustment] = None


# --- MPG & RV & MUFS -------------------------------------------------------


class MpgEvidencePreview(BaseModel):
    evidence_id: str
    snippet: str
    source_class: str
    timestamp_utc: datetime


class MpgNodeMetrics(BaseModel):
    valence: float = Field(ge=-1.0, le=1.0)
    intensity: float = Field(ge=0.0, le=1.0)
    recency: float = Field(ge=0.0, le=1.0)
    stability: float = Field(ge=0.0, le=1.0)


class MpgNode(BaseModel):
    id: str
    label: str
    description: Optional[str] = None

    layer_tags: List[str] = Field(default_factory=list)
    metrics: MpgNodeMetrics
    confidence: float = Field(ge=0.0, le=1.0)
    importance: float = Field(ge=0.0, le=1.0)
    roles: List[str] = Field(default_factory=list)
    evidence_preview: List[MpgEvidencePreview] = Field(default_factory=list)
    reasoning_provenance: Optional[str] = None


class MpgEdge(BaseModel):
    id: str
    source: str
    target: str
    type: str
    strength: float = Field(ge=0.0, le=1.0)
    confidence: float = Field(ge=0.0, le=1.0)


class MpgSegment(BaseModel):
    id: str
    label: str
    level: int
    member_node_ids: List[str]
    cohesion: float = Field(ge=0.0, le=1.0)
    average_importance: float = Field(ge=0.0, le=1.0)
    average_confidence: float = Field(ge=0.0, le=1.0)
    affective_load: Optional[float] = Field(default=None, ge=0.0, le=1.0)


class MpgOperation(BaseModel):
    kind: Literal[
        "add_node",
        "update_node",
        "add_edge",
        "update_edge",
        "add_segment",
        "update_segment",
    ]
    node: Optional[MpgNode] = None
    node_id: Optional[str] = None
    edge: Optional[MpgEdge] = None
    edge_id: Optional[str] = None
    segment: Optional[MpgSegment] = None
    segment_id: Optional[str] = None
    patch: Optional[Dict[str, Any]] = None


class MpgDeltaPayload(BaseModel):
    mpg_id: str
    level: int
    delta_id: str
    operations: List[MpgOperation]


class RogueVariableImpactFactors(BaseModel):
    rate_of_change: float = Field(ge=0.0, le=1.0)
    breadth_of_impact: float = Field(ge=0.0, le=1.0)
    amplification: float = Field(ge=0.0, le=1.0)
    emotional_load: float = Field(ge=0.0, le=1.0)
    gate_leverage: float = Field(ge=0.0, le=1.0)
    robustness: float = Field(ge=0.0, le=1.0)


class RogueVariableShapleyStats(BaseModel):
    mean_abs_contrib: float
    std_abs_contrib: float
    candidate_abs_contrib: float
    z_score: float


class RogueVariableEventPayload(BaseModel):
    rogue_id: str
    mpg_id: str
    candidate_type: Literal["segment", "pathway"]
    level_range: Tuple[int, int]
    segment_ids: Optional[List[str]] = None
    pathway_nodes: Optional[List[str]] = None
    shapley_stats: RogueVariableShapleyStats
    potency_index: float
    impact_factors: RogueVariableImpactFactors


class DecisionUtility(BaseModel):
    choice: str
    utility: Dict[str, float]


class MufsEventPayload(BaseModel):
    mufs_id: str
    decision_id: str
    mpg_id: str

    unawareness_types: List[UnawarenessType]
    input_unaware_refs: Optional[List[str]] = None
    process_unaware_node_ids: Optional[List[str]] = None

    decision_full: DecisionUtility
    decision_without_U: DecisionUtility

    minimal: bool
    search_metadata: Optional[Dict[str, Any]] = None


# --- envelope ---------------------------------------------------------------

PayloadT = TypeVar(
    "PayloadT",
    SomaticStatePayload,
    SymbolicStatePayload,
    NoeticStatePayload,
    DecisionCyclePayload,
    MpgDeltaPayload,
    RogueVariableEventPayload,
    MufsEventPayload,
)


class TelemetryEnvelope(BaseModel, Generic[PayloadT]):
    v: Literal["1"] = "1"
    message_type: MessageType
    timestamp_utc: datetime
    experiment_id: str
    session_id: str
    subject_id: str
    run_id: Optional[str] = None
    sork_cycle_id: Optional[str] = None
    decision_id: Optional[str] = None
    source_layer: SourceLayer
    sequence: int
    payload: PayloadT
```

---

### 2.3 `api.py` â€“ Responses & DTOs for CRâ€‘302

```python
# backend/app/schemas/api.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import BaseModel

from .telemetry import (
    DecisionCyclePayload,
    MpgDeltaPayload,
    MpgEdge,
    MpgNode,
    MpgSegment,
    MufsEventPayload,
    NoeticStatePayload,
    RogueVariableEventPayload,
    SomaticStatePayload,
    SymbolicStatePayload,
    TelemetryEnvelope,
)


class SessionSummary(BaseModel):
    session_id: str
    experiment_id: str
    subject_id: str
    status: str  # "active" | "completed"
    started_utc: str
    ended_utc: Optional[str] = None


class MpgLevelSummary(BaseModel):
    level: int
    node_count: int
    segment_count: int


class MpgSubgraphResponse(BaseModel):
    mpg_id: str
    level: int
    center_node_id: Optional[str] = None
    nodes: List[MpgNode]
    edges: List[MpgEdge]
    segments: List[MpgSegment]


class SnapshotMpg(BaseModel):
    mpg_id: str
    level_summaries: List[MpgLevelSummary]
    base_subgraph: MpgSubgraphResponse


class SnapshotResponse(BaseModel):
    session_id: str
    t_rel_ms: int
    somatic: SomaticStatePayload
    symbolic: SymbolicStatePayload
    noetic: NoeticStatePayload
    last_decision_cycle: Optional[DecisionCyclePayload] = None
    mpg: SnapshotMpg


class ReplayResponse(BaseModel):
    session_id: str
    from_ms: int
    to_ms: int
    messages: List[TelemetryEnvelope[Any]]


class DecisionTraceResponse(BaseModel):
    session_id: str
    decision_id: str
    phases: List[DecisionCyclePayload]
    mufs_events: List[MufsEventPayload] = []
    rogue_variable_events: List[RogueVariableEventPayload] = []
    mpg_full: Optional[MpgSubgraphResponse] = None
    mpg_without_mufs: Optional[MpgSubgraphResponse] = None
```

---

## 3. Backend: FastAPI Wiring Example

Add a router module:

```text
backend/app/api/
  __init__.py
  sessions.py
  stream.py
```

### 3.1 `sessions.py` (snapshot + replay)

```python
# backend/app/api/sessions.py
from fastapi import APIRouter, HTTPException, Query

from ..schemas.api import (
    DecisionTraceResponse,
    MpgSubgraphResponse,
    ReplayResponse,
    SessionSummary,
    SnapshotResponse,
)

router = APIRouter(prefix="/v1/sessions", tags=["sessions"])


@router.get("", response_model=list[SessionSummary])
async def list_sessions() -> list[SessionSummary]:
    # TODO: query from Timescale/Postgres
    return []


@router.get("/{session_id}/snapshot", response_model=SnapshotResponse)
async def get_snapshot(session_id: str, t_rel_ms: int | None = None) -> SnapshotResponse:
    # TODO: pull most recent (or given t_rel_ms) state from DB
    raise HTTPException(status_code=501, detail="Not implemented")


@router.get(
    "/{session_id}/replay",
    response_model=ReplayResponse,
)
async def get_replay(
    session_id: str,
    from_ms: int = Query(..., ge=0),
    to_ms: int = Query(..., ge=0),
    message_types: str = Query(
        "somatic_state,symbolic_state,noetic_state,mpg_delta",
        description="Comma-separated message types",
    ),
    max_messages: int = Query(5000, ge=1, le=20000),
) -> ReplayResponse:
    # TODO: query TimescaleDB
    raise HTTPException(status_code=501, detail="Not implemented")


@router.get(
    "/{session_id}/mpg/{level}/subgraph",
    response_model=MpgSubgraphResponse,
)
async def get_mpg_subgraph(
    session_id: str,
    level: int,
    center_node_id: str | None = None,
    radius: int = 2,
    max_nodes: int = 500,
) -> MpgSubgraphResponse:
    # TODO: query Neo4j
    raise HTTPException(status_code=501, detail="Not implemented")


@router.get(
    "/{session_id}/decisions/{decision_id}",
    response_model=DecisionTraceResponse,
)
async def get_decision_trace(
    session_id: str,
    decision_id: str,
) -> DecisionTraceResponse:
    # TODO: join SORK-N events + MUFS + RV
    raise HTTPException(status_code=501, detail="Not implemented")
```

### 3.2 `stream.py` (WebSocket)

```python
# backend/app/api/stream.py
from typing import Any, Dict, List

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from pydantic import BaseModel

from ..schemas.telemetry import TelemetryEnvelope

router = APIRouter(prefix="/v1", tags=["stream"])


class StreamSubscribe(BaseModel):
    type: str
    session_id: str
    message_types: List[str]


class StreamAck(BaseModel):
    type: str = "ack"
    subscription_id: str


class StreamEvent(BaseModel):
    type: str = "event"
    subscription_id: str
    data: TelemetryEnvelope[Any]


@router.websocket("/stream")
async def websocket_stream(ws: WebSocket) -> None:
    await ws.accept(subprotocol="json_v1")
    try:
        msg = await ws.receive_json()
        sub = StreamSubscribe(**msg)
        sub_id = f"sub_{sub.session_id}"
        await ws.send_json(StreamAck(subscription_id=sub_id).dict())

        # TODO: hook into internal pub/sub and forward events
        while True:
            # placeholder: ping to keep alive
            await ws.send_json(
                StreamEvent(
                    subscription_id=sub_id,
                    data=TelemetryEnvelope(
                        message_type="somatic_state",  # type: ignore
                        timestamp_utc="1970-01-01T00:00:00Z",
                        experiment_id="dummy",
                        session_id=sub.session_id,
                        subject_id="dummy",
                        source_layer="Somatic",  # type: ignore
                        sequence=0,
                        payload={},
                    ),
                ).dict()
            )
            await ws.receive_text()  # block; replaced with real event loop
    except WebSocketDisconnect:
        return
```

(Logic is placeholder; the key part is the **shape** of WebSocket messages.)

---

## 4. Frontend: TypeScript Types

Create a shared types module:

```text
frontend/src/api/types.ts
frontend/src/api/client.ts
frontend/src/state/useH3lixStore.ts
frontend/src/components/H3lixScene.tsx
```

For now we **mirror** the Pydantic models manually (in practice, you can generate TS from OpenAPI or JSON Schema).

### 4.1 `types.ts`

```ts
// frontend/src/api/types.ts

export type MessageType =
  | "somatic_state"
  | "symbolic_state"
  | "noetic_state"
  | "decision_cycle"
  | "mpg_delta"
  | "rogue_variable_event"
  | "mufs_event";

export type SourceLayer =
  | "Somatic"
  | "Symbolic"
  | "Noetic"
  | "MirrorCore"
  | "MPG";

export type StreamName = "somatic" | "symbolic" | "behavioral" | "external";

export interface SomaticAnticipatoryMarker {
  marker_type: "readiness_like" | "phase_locking" | "other";
  lead_time_ms: number;
  confidence: number;
}

export interface SomaticStatePayload {
  t_rel_ms: number;
  window_ms: number;
  features: Record<string, number>;
  innovation?: Record<string, number>;
  covariance_diag?: Record<string, number>;
  global_uncertainty_score?: number;
  change_point: boolean;
  anomaly_score?: number;
  anticipatory_markers: SomaticAnticipatoryMarker[];
}

export interface SymbolicBelief {
  id: string;
  kind: "entity" | "event" | "relation" | "policy";
  label: string;
  description?: string;
  valence?: number;
  intensity?: number;
  recency?: number;
  stability?: number;
  confidence: number;
  importance: number;
}

export interface SymbolicPredictionOption {
  value: string;
  probability: number;
}

export interface SymbolicPrediction {
  id: string;
  target_type: "word" | "event" | "outcome";
  horizon_ms?: number;
  topk: SymbolicPredictionOption[];
  brier_score?: number;
  realized_value?: string;
  realized_error?: number;
}

export interface SymbolicUncertaintyRegion {
  label: string;
  belief_ids: string[];
  comment?: string;
}

export interface SymbolicStatePayload {
  t_rel_ms: number;
  belief_revision_id: string;
  beliefs: SymbolicBelief[];
  predictions: SymbolicPrediction[];
  uncertainty_regions: SymbolicUncertaintyRegion[];
}

export interface NoeticStreamCorrelation {
  stream_x: StreamName;
  stream_y: StreamName;
  r: number;
}

export interface NoeticSpectrumBand {
  band_label: string;
  freq_range_hz: [number, number];
  coherence_strength: number;
}

export interface NoeticIntuitiveAccuracyEstimate {
  p_better_than_baseline: number;
  calibration_error?: number;
}

export interface NoeticStatePayload {
  t_rel_ms: number;
  window_ms: number;
  global_coherence_score: number;
  entropy_change: number;
  stream_correlations: NoeticStreamCorrelation[];
  coherence_spectrum: NoeticSpectrumBand[];
  intuitive_accuracy_estimate?: NoeticIntuitiveAccuracyEstimate;
}

export interface DecisionAction {
  action_id: string;
  label: string;
  params?: Record<string, unknown>;
}

export interface DecisionOutcome {
  label: string;
  metrics: Record<string, number>;
}

export interface NoeticAdjustment {
  attention_gain?: number;
  decision_threshold_delta?: number;
  learning_rate_delta?: number;
}

export interface DecisionCyclePayload {
  sork_cycle_id: string;
  decision_id?: string;
  phase: "S" | "O" | "R" | "K" | "N" | "S_prime";
  phase_started_utc: string;
  phase_ended_utc?: string;
  stimulus_refs?: { channel: string; ref_id: string }[];
  organism_belief_ids?: string[];
  response_action?: DecisionAction;
  consequence_outcome?: DecisionOutcome;
  noetic_adjustments?: NoeticAdjustment;
}

export interface MpgEvidencePreview {
  evidence_id: string;
  snippet: string;
  source_class: string;
  timestamp_utc: string;
}

export interface MpgNodeMetrics {
  valence: number;
  intensity: number;
  recency: number;
  stability: number;
}

export interface MpgNode {
  id: string;
  label: string;
  description?: string;
  layer_tags: string[];
  metrics: MpgNodeMetrics;
  confidence: number;
  importance: number;
  roles: string[];
  evidence_preview: MpgEvidencePreview[];
  reasoning_provenance?: string;
}

export interface MpgEdge {
  id: string;
  source: string;
  target: string;
  type: string;
  strength: number;
  confidence: number;
}

export interface MpgSegment {
  id: string;
  label: string;
  level: number;
  member_node_ids: string[];
  cohesion: number;
  average_importance: number;
  average_confidence: number;
  affective_load?: number;
}

export type UnawarenessType = "IU" | "PU";

export interface RogueVariableImpactFactors {
  rate_of_change: number;
  breadth_of_impact: number;
  amplification: number;
  emotional_load: number;
  gate_leverage: number;
  robustness: number;
}

export interface RogueVariableShapleyStats {
  mean_abs_contrib: number;
  std_abs_contrib: number;
  candidate_abs_contrib: number;
  z_score: number;
}

export interface RogueVariableEventPayload {
  rogue_id: string;
  mpg_id: string;
  candidate_type: "segment" | "pathway";
  level_range: [number, number];
  segment_ids?: string[];
  pathway_nodes?: string[];
  shapley_stats: RogueVariableShapleyStats;
  potency_index: number;
  impact_factors: RogueVariableImpactFactors;
}

export interface DecisionUtility {
  choice: string;
  utility: Record<string, number>;
}

export interface MufsEventPayload {
  mufs_id: string;
  decision_id: string;
  mpg_id: string;
  unawareness_types: UnawarenessType[];
  input_unaware_refs?: string[];
  process_unaware_node_ids?: string[];
  decision_full: DecisionUtility;
  decision_without_U: DecisionUtility;
  minimal: boolean;
  search_metadata?: Record<string, unknown>;
}

export interface TelemetryEnvelope<TPayload> {
  v: "1";
  message_type: MessageType;
  timestamp_utc: string;
  experiment_id: string;
  session_id: string;
  subject_id: string;
  run_id?: string;
  sork_cycle_id?: string;
  decision_id?: string;
  source_layer: SourceLayer;
  sequence: number;
  payload: TPayload;
}

// API responses --------------------------------------------------------------

export interface SessionSummary {
  session_id: string;
  experiment_id: string;
  subject_id: string;
  status: "active" | "completed";
  started_utc: string;
  ended_utc?: string | null;
}

export interface MpgLevelSummary {
  level: number;
  node_count: number;
  segment_count: number;
}

export interface MpgSubgraphResponse {
  mpg_id: string;
  level: number;
  center_node_id?: string;
  nodes: MpgNode[];
  edges: MpgEdge[];
  segments: MpgSegment[];
}

export interface SnapshotMpg {
  mpg_id: string;
  level_summaries: MpgLevelSummary[];
  base_subgraph: MpgSubgraphResponse;
}

export interface SnapshotResponse {
  session_id: string;
  t_rel_ms: number;
  somatic: SomaticStatePayload;
  symbolic: SymbolicStatePayload;
  noetic: NoeticStatePayload;
  last_decision_cycle?: DecisionCyclePayload;
  mpg: SnapshotMpg;
}

export interface ReplayResponse {
  session_id: string;
  from_ms: number;
  to_ms: number;
  messages: TelemetryEnvelope<unknown>[];
}

export interface DecisionTraceResponse {
  session_id: string;
  decision_id: string;
  phases: DecisionCyclePayload[];
  mufs_events: MufsEventPayload[];
  rogue_variable_events: RogueVariableEventPayload[];
  mpg_full?: MpgSubgraphResponse;
  mpg_without_mufs?: MpgSubgraphResponse;
}
```

---

## 5. Frontend: API Client

### 5.1 `client.ts`

```ts
// frontend/src/api/client.ts
import {
  DecisionTraceResponse,
  ReplayResponse,
  SessionSummary,
  SnapshotResponse,
  TelemetryEnvelope,
} from "./types";

const API_BASE = "/v1";

export async function listSessions(): Promise<SessionSummary[]> {
  const res = await fetch(`${API_BASE}/sessions`);
  if (!res.ok) throw new Error("Failed to list sessions");
  return res.json();
}

export async function getSnapshot(
  sessionId: string,
  tRelMs?: number
): Promise<SnapshotResponse> {
  const url = new URL(`${API_BASE}/sessions/${sessionId}/snapshot`, window.location.origin);
  if (tRelMs != null) url.searchParams.set("t_rel_ms", String(tRelMs));
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error("Failed to fetch snapshot");
  return res.json();
}

export async function getReplay(
  sessionId: string,
  fromMs: number,
  toMs: number
): Promise<ReplayResponse> {
  const url = new URL(`${API_BASE}/sessions/${sessionId}/replay`, window.location.origin);
  url.searchParams.set("from_ms", String(fromMs));
  url.searchParams.set("to_ms", String(toMs));
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error("Failed to fetch replay");
  return res.json();
}

// --- WebSocket stream -------------------------------------------------------

export type StreamEvent<TPayload = unknown> = {
  type: "event";
  subscription_id: string;
  data: TelemetryEnvelope<TPayload>;
};

export type StreamAck = { type: "ack"; subscription_id: string };
export type StreamMessage = StreamEvent | StreamAck;

export function openStream(
  sessionId: string,
  messageTypes: string[],
  onEvent: (ev: StreamEvent) => void,
  onClose?: () => void
): WebSocket {
  const ws = new WebSocket(
    `${window.location.origin.replace(/^http/, "ws")}${API_BASE}/stream`,
    "json_v1"
  );

  ws.onopen = () => {
    const subMsg = {
      type: "subscribe",
      session_id: sessionId,
      message_types: messageTypes,
    };
    ws.send(JSON.stringify(subMsg));
  };

  ws.onmessage = (evt) => {
    const data = JSON.parse(evt.data) as StreamMessage;
    if (data.type === "event") {
      onEvent(data);
    }
  };

  ws.onclose = () => {
    onClose?.();
  };

  return ws;
}
```

---

## 6. Frontend: Minimal State Store + Scene Stub

### 6.1 `useH3lixStore.ts` (Zustand example)

```ts
// frontend/src/state/useH3lixStore.ts
import create from "zustand";
import {
  SnapshotResponse,
  TelemetryEnvelope,
  SomaticStatePayload,
  SymbolicStatePayload,
  NoeticStatePayload,
  MpgDeltaPayload,
} from "../api/types";

type AnyEnvelope =
  | TelemetryEnvelope<SomaticStatePayload>
  | TelemetryEnvelope<SymbolicStatePayload>
  | TelemetryEnvelope<NoeticStatePayload>
  | TelemetryEnvelope<MpgDeltaPayload>;

interface H3lixState {
  snapshot?: SnapshotResponse;
  somatic?: SomaticStatePayload;
  symbolic?: SymbolicStatePayload;
  noetic?: NoeticStatePayload;
  mpgDeltas: MpgDeltaPayload[];
  setSnapshot: (s: SnapshotResponse) => void;
  applyEnvelope: (env: AnyEnvelope) => void;
}

export const useH3lixStore = create<H3lixState>((set) => ({
  snapshot: undefined,
  somatic: undefined,
  symbolic: undefined,
  noetic: undefined,
  mpgDeltas: [],
  setSnapshot: (snapshot) => set({ snapshot, somatic: snapshot.somatic, symbolic: snapshot.symbolic, noetic: snapshot.noetic }),
  applyEnvelope: (env) =>
    set((state) => {
      switch (env.message_type) {
        case "somatic_state":
          return { ...state, somatic: env.payload as SomaticStatePayload };
        case "symbolic_state":
          return { ...state, symbolic: env.payload as SymbolicStatePayload };
        case "noetic_state":
          return { ...state, noetic: env.payload as NoeticStatePayload };
        case "mpg_delta":
          return {
            ...state,
            mpgDeltas: [...state.mpgDeltas, env.payload as MpgDeltaPayload],
          };
        default:
          return state;
      }
    }),
}));
```

### 6.2 `H3lixScene.tsx` â€“ hook up snapshot + stream

```tsx
// frontend/src/components/H3lixScene.tsx
import React, { useEffect } from "react";
import { Canvas } from "@react-three/fiber";
import { getSnapshot, openStream } from "../api/client";
import { useH3lixStore } from "../state/useH3lixStore";

type Props = { sessionId: string };

export const H3lixScene: React.FC<Props> = ({ sessionId }) => {
  const setSnapshot = useH3lixStore((s) => s.setSnapshot);
  const applyEnvelope = useH3lixStore((s) => s.applyEnvelope);

  useEffect(() => {
    let ws: WebSocket | undefined;

    (async () => {
      const snap = await getSnapshot(sessionId);
      setSnapshot(snap);

      ws = openStream(
        sessionId,
        [
          "somatic_state",
          "symbolic_state",
          "noetic_state",
          "mpg_delta",
        ],
        (ev) => applyEnvelope(ev.data as any)
      );
    })().catch(console.error);

    return () => {
      ws?.close();
    };
  }, [sessionId, setSnapshot, applyEnvelope]);

  // TODO: read somatic/symbolic/noetic/mpgDeltas from store
  // and render triple helix + MPG city

  return (
    <Canvas camera={{ position: [0, 0, 10], fov: 45 }}>
      {/* placeholder: replace with actual helix / city components */}
      <mesh>
        <torusKnotGeometry args={[1, 0.3, 100, 16]} />
        <meshStandardMaterial />
      </mesh>
      <ambientLight />
      <pointLight position={[5, 5, 5]} />
    </Canvas>
  );
};
```

---

## 7. Acceptance Criteria

- Backend:
  - `telemetry.py` and `api.py` compile and pass basic tests (`mypy` optional).
  - FastAPI exposes `/v1/sessions/*` and `/v1/stream` with these models.
  - OpenAPI docs show the same shapes the frontend uses.

- Frontend:
  - TypeScript compiles (`tsc` clean).
  - `H3lixScene` can:
    - Load `/snapshot` for a chosen session.
    - Connect to `/stream` and update Zustand state when telemetry events arrive.

Once this CR is implemented, both sides are speaking the same **typed language** for Somatic, Symbolic, Noetic, MPG, Rogue Variables and MUFS, directly mirroring the constructs in the H3LIX / LAIZA paper.  [oai_citation:1â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_00000000a2f071f4a36d5a4040b12b83)
