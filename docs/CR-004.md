**Change Request: CRâ€‘004 â€“ MUFS Search & MPGâ€‘Intuition Experiment Harness**

---

## 1. Objective

Extend CRâ€‘001â€“CRâ€‘003 to implement the **MPGâ€‘Intuition** machinery:

1. Implement **Minimal Unaware Flip Set (MUFS)** search for each *restricted* trial, matching Definitions 7â€“8 (Input Unawareness, Process Unawareness, MUFS, and MPGâ€‘Intuition).  [oai_citation:0â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
2. Label trials as **MPGâ€‘Intuitive** when a nonempty MUFS exists.  [oai_citation:1â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
3. Wire this into the existing Python + Neo4j stack:
   - Represent **awareness conditions** (FULL, IU, PU) on `:Trial` nodes.
   - Store MUFS sets (inputs + MPG structures) in Neo4j.
   - Provide a **Python search harness** that runs full vs restricted blocks (systemâ€‘only level of Sec. 6) and records MUFS stats.  [oai_citation:2â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
4. Add simple queries / helper functions so the Mirror Core and Noetic layer can ask:
   - â€œWhich restricted trials are MPGâ€‘Intuitive?â€
   - â€œHow does MUFS incidence relate to coherence and Potency Index?â€

This directly operationalizes **Section 5 (MPGâ€‘Intuition model)** and **Section 6 (Experimental Strategy)** in your running system.  [oai_citation:3â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 2. Scope

### In scope

- **Schema additions in Neo4j**:
  - Awareness annotations on `:Trial`.
  - MUFS representation (`:MUFS` node + links to inputs and segments).
- **Python components**:
  - A `DecisionEngine` abstraction with **full vs restricted** evaluation.
  - A **MUFS search algorithm** (greedy + minimality check) over:
    - **Input features** (IU).
    - **Segments / structural variables** (PU, using RV/potency infrastructure from CRâ€‘002/3).
  - Script `scripts/mufs_search_demo.py` to:
    - Run synthetic â€œfull vs restrictedâ€ blocks.
    - Compute MUFS per restricted trial.
    - Mark **MPGâ€‘Intuitive** trials in Neo4j.

### Out of scope

- Human participants, psychophysical masking, and GUIs for selfâ€‘report (these are in the paperâ€™s broader program but not coded here).  [oai_citation:4â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Fully optimized MUFS search (we implement a practical approximation suitable to iterate on).

---

## 3. Theory recap (what weâ€™re implementing)

From Section 5 of the paper:

- We have an MPG hierarchy `MPG = {G^(0), â€¦, G^(N)}` and a decision rule  
  `Ä¥ = Ä¥(O, MPG, R(H))` over decision set Hâ‚€ and observations `O = {oâ‚,â€¦,o_m}`.  [oai_citation:5â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- **Input Unawareness (IU)**: conscious inputs `ÅŒ` are a proper subset of O, with unaware inputs `U_in = O \ ÅŒ`.  [oai_citation:6â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- **Process Unawareness (PU)**: unaware parts of MPG, `U_proc âŠ† MPG`; combined unaware set `U = U_in âˆª U_proc`.  [oai_citation:7â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- **Minimal Unaware Flip Set (MUFS)** (Def. 7):  
  A set `U âŠ‚ ð’°` is a MUFS iff *removing* all elements in U flips Ä¥, but removing any proper subset does not.  [oai_citation:8â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- **MPGâ€‘Intuition (Def. 8)**: a decision is MPGâ€‘Intuitive iff at least one **nonempty MUFS** exists.  [oai_citation:9â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

And in Section 6, systemâ€‘only experiments:

- Run blocks under **Full** vs **Restricted** (IU and/or PU) awareness.
- For each restricted trial, **LAIZA searches** for a MUFS whose restoration reverses the decision, and measures: MUFS incidence, flip rates, and link to Noetic coherence.  [oai_citation:10â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

Weâ€™ll implement a practical variant:

- Start from a **restricted trial decision** `Ä¥_restricted`.  
- Consider the **set of unavailable factors** U.  
- Search for the smallest subset U* âŠ† U whose **restoration** (unmasking) changes the decision. This is symmetric to Def. 7 (â€œremovingâ€) and easier to implement.

---

## 4. Schema changes (Neo4j)

### 4.1 `:Trial` nodes

Extend your existing `:Trial` nodes (from earlier CRs) with awareness info and intuition flags:

```cypher
// Example schema extension
MATCH (t:Trial)
SET t.awareness_condition = coalesce(t.awareness_condition, "FULL"),  // FULL | IU | PU | MIX
    t.mask_type          = coalesce(t.mask_type, "NONE"),             // e.g., "IU_ONLY", "PU_ONLY", "BOTH"
    t.has_mufs           = coalesce(t.has_mufs, false),
    t.mufs_size          = coalesce(t.mufs_size, 0),
    t.mufs_type          = coalesce(t.mufs_type, "NONE"),             // "IU", "PU", "MIX", "NONE"
    t.mpg_intuitive      = coalesce(t.mpg_intuitive, false);
```

Relationships (if not already present):

- `(:Session)-[:HAS_TRIAL]->(:Trial)`
- `(:Trial)-[:USES_SEGMENT]->(:Segment)` â€“ segments that are structurally relevant to that trial (from Symbolic/MPG pipeline).

### 4.2 MUFS representation

Introduce a `:MUFS` node per trial (or per MUFS variant):

```cypher
CREATE CONSTRAINT mufs_id IF NOT EXISTS
FOR (m:MUFS) REQUIRE m.id IS UNIQUE;
```

Properties:

- `id: string`
- `trial_id: string`
- `awareness_condition: string` (IU, PU, MIX)
- `size: int`
- `created_at: datetime`

Relationships:

- `(:Trial)-[:HAS_MUFS]->(:MUFS)`
- For **inputâ€‘level** MUFS elements:

  - `(:MUFS)-[:INCLUDES_INPUT]->(:InputFactor)` or (simpler) store as an array on MUFS: `input_keys: [string]`.

- For **processâ€‘level** MUFS elements:

  - `(:MUFS)-[:INCLUDES_SEGMENT]->(:Segment)` for each MPG segment in U_proc.

For now weâ€™ll use:

- `:MUFS.input_keys : [string]` â€“ IDs/names of masked features.  
- `(:MUFS)-[:INCLUDES_SEGMENT]->(:Segment)` â€“ structural MUFS elements.

---

## 5. Python design

Weâ€™ll add a MUFS search harness in `scripts/mufs_search_demo.py`.

### 5.1 Decision engine abstraction

A thin wrapper around whatever model you use (RandomForest, LLMâ€‘based planner, etc.) that can:

- Evaluate a **full** trial.
- Evaluate under **input masks** (IU) and **segment masks** (PU).

```python
# scripts/mufs_search_demo.py

from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple, Callable
import uuid
import itertools
import numpy as np
from neo4j import GraphDatabase

# ---- Decision engine ----

@dataclass
class TrialConfig:
    trial_id: str
    features_full: Dict[str, float]          # all input features
    segments_full: List[str]                # relevant segment ids
    # which inputs/segments are hidden in restricted condition
    hidden_inputs: List[str]
    hidden_segments: List[str]


class DecisionEngine:
    """
    Abstraction for hÌ‚ = hÌ‚(O, MPG).
    For demo, we assume a simple classifier over numeric features and segment indicators.
    """

    def __init__(self, model, feature_order: List[str], segment_order: List[str]):
        self.model = model                  # e.g. sklearn classifier
        self.feature_order = feature_order
        self.segment_order = segment_order

    def _vectorize(
        self,
        features: Dict[str, float],
        segments: List[str],
    ) -> np.ndarray:
        x_num = [features.get(k, 0.0) for k in self.feature_order]
        x_seg = [(1.0 if sid in segments else 0.0) for sid in self.segment_order]
        return np.array(x_num + x_seg, dtype=float).reshape(1, -1)

    def decide(
        self,
        features: Dict[str, float],
        segments: List[str],
    ) -> int:
        x = self._vectorize(features, segments)
        yhat = self.model.predict(x)[0]
        return int(yhat)
```

This is your `Ä¥(O, MPG)` function.

### 5.2 Applying IU and PU masks

Utility to simulate restricted awareness:

```python
def apply_masks(
    cfg: TrialConfig,
    mask_inputs: List[str],
    mask_segments: List[str],
) -> Tuple[Dict[str, float], List[str]]:
    # Input masking: remove or zero-out hidden inputs
    features = dict(cfg.features_full)
    for key in mask_inputs:
        if key in features:
            features[key] = 0.0  # or None/NaN depending on model

    # Process masking: ablate segments
    segments = [s for s in cfg.segments_full if s not in mask_segments]
    return features, segments
```

- In **full** condition: `mask_inputs = []`, `mask_segments = []`.  
- In **restricted** condition: `mask_inputs = cfg.hidden_inputs`, `mask_segments = cfg.hidden_segments`.

### 5.3 MUFS search algorithm

We follow the spirit of Def. 7 but implement a **greedy + minimality check** search:

- U = union of hidden inputs and segments.  
- Start from restricted masks (everything in U masked).  
- Add back candidates (i.e., *remove from mask*) in order of importance until decision flips.  
- Once we find a flipping set, **shrink** it to minimal.

Importance heuristics:

- For **inputs**: SHAP contributions if available, else absolute model weights or mutual information.  
- For **segments**: use **Potency Index** / RV score from CRâ€‘002/3.

Example:

```python
@dataclass
class MufsResult:
    exists: bool
    input_keys: List[str]
    segment_ids: List[str]


def mufs_search(
    engine: DecisionEngine,
    cfg: TrialConfig,
    input_score: Dict[str, float],
    segment_score: Dict[str, float],
    max_subset_size: int = 5,
) -> MufsResult:
    """
    Search for a Minimal Unaware Flip Set U* by restoring elements from U
    (mask -> unmask) until the decision changes.
    - input_score, segment_score: importance scores for ranking U elements
      (e.g. SHAP for inputs; potency for segments).
    """

    # 1) Baseline restricted decision
    features_restricted, segs_restricted = apply_masks(
        cfg, cfg.hidden_inputs, cfg.hidden_segments
    )
    h_restricted = engine.decide(features_restricted, segs_restricted)

    # 2) Define candidate universe U = U_in âˆª U_proc
    U_inputs = list(cfg.hidden_inputs)
    U_segs = list(cfg.hidden_segments)

    # Rank by importance descending
    U_inputs_sorted = sorted(U_inputs, key=lambda k: input_score.get(k, 0.0), reverse=True)
    U_segs_sorted = sorted(U_segs, key=lambda sid: segment_score.get(sid, 0.0), reverse=True)

    # Helper to evaluate decision given a subset of restored elements
    def decision_with_restored(
        restored_inputs: List[str],
        restored_segs: List[str],
    ) -> int:
        # mask = U \ restored
        mask_inputs = [k for k in U_inputs if k not in restored_inputs]
        mask_segs = [sid for sid in U_segs if sid not in restored_segs]
        feats, segs = apply_masks(cfg, mask_inputs, mask_segs)
        return engine.decide(feats, segs)

    # 3) Greedy expansion: try adding back important elements up to max_subset_size
    candidate_inputs: List[str] = []
    candidate_segs: List[str] = []

    for _ in range(max_subset_size):
        # Evaluate marginal benefit of restoring each remaining item
        best_item = None
        best_type = None
        best_flip = False

        # Check inputs
        for key in U_inputs_sorted:
            if key in candidate_inputs:
                continue
            tmp_inputs = candidate_inputs + [key]
            h_tmp = decision_with_restored(tmp_inputs, candidate_segs)
            if h_tmp != h_restricted:
                best_item = key
                best_type = "input"
                best_flip = True
                break  # first flipper is enough in greedy

        # If no input flips, try segments
        if not best_flip:
            for sid in U_segs_sorted:
                if sid in candidate_segs:
                    continue
                tmp_segs = candidate_segs + [sid]
                h_tmp = decision_with_restored(candidate_inputs, tmp_segs)
                if h_tmp != h_restricted:
                    best_item = sid
                    best_type = "seg"
                    best_flip = True
                    break

        if not best_flip:
            # No more items flip the decision â†’ no MUFS found within search budget
            return MufsResult(False, [], [])

        # Add chosen item
        if best_type == "input":
            candidate_inputs.append(best_item)
        else:
            candidate_segs.append(best_item)

        # Check if current candidate already flips
        h_curr = decision_with_restored(candidate_inputs, candidate_segs)
        if h_curr != h_restricted:
            # Found a flipping set; proceed to minimality check
            break

    # 4) Minimality refinement: try removing each element
    changed = True
    while changed:
        changed = False
        # Try to remove each input and see if flip still holds
        for key in list(candidate_inputs):
            tmp = [k for k in candidate_inputs if k != key]
            h_tmp = decision_with_restored(tmp, candidate_segs)
            if h_tmp != h_restricted:
                candidate_inputs = tmp
                changed = True
        # Try segments
        for sid in list(candidate_segs):
            tmp = [s for s in candidate_segs if s != sid]
            h_tmp = decision_with_restored(candidate_inputs, tmp)
            if h_tmp != h_restricted:
                candidate_segs = tmp
                changed = True

    if not candidate_inputs and not candidate_segs:
        return MufsResult(False, [], [])

    return MufsResult(True, candidate_inputs, candidate_segs)
```

This gives you a **concrete U\*** per restricted trial.

---

## 6. Neo4j integration helpers

Extend a Neo4j client to store MUFS results and mark MPGâ€‘Intuitive trials:

```python
class LAIZANeo4j:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def run(self, query, **params):
        with self.driver.session() as session:
            return list(session.run(query, **params))

    def create_mufs(
        self,
        trial_id: str,
        awareness_condition: str,
        input_keys: List[str],
        segment_ids: List[str],
    ) -> str:
        mufs_id = str(uuid.uuid4())
        q = """
        MATCH (t:Trial {id: $trial_id})
        CREATE (m:MUFS {
            id: $id,
            trial_id: $trial_id,
            awareness_condition: $ac,
            size: $size,
            input_keys: $input_keys,
            created_at: datetime()
        })
        CREATE (t)-[:HAS_MUFS]->(m)
        WITH m
        UNWIND $segment_ids AS sid
        MATCH (s:Segment {id: sid})
        CREATE (m)-[:INCLUDES_SEGMENT]->(s)
        """
        self.run(
            q,
            trial_id=trial_id,
            id=mufs_id,
            ac=awareness_condition,
            size=len(input_keys) + len(segment_ids),
            input_keys=input_keys,
            segment_ids=segment_ids,
        )
        return mufs_id

    def mark_trial_intuition(
        self,
        trial_id: str,
        mufs_size: int,
        has_mufs: bool,
        mufs_type: str,
    ):
        q = """
        MATCH (t:Trial {id: $id})
        SET t.has_mufs = $has_mufs,
            t.mufs_size = $mufs_size,
            t.mufs_type = $mufs_type,
            t.mpg_intuitive = $has_mufs
        """
        self.run(
            q,
            id=trial_id,
            has_mufs=has_mufs,
            mufs_size=mufs_size,
            mufs_type=mufs_type,
        )
```

`mufs_type` can be:

- `"IU"` if MUFS only contains inputs.  
- `"PU"` if MUFS only contains segments.  
- `"MIX"` otherwise.

---

## 7. Systemâ€‘only experiment harness

`main()` in `mufs_search_demo.py`:

- Loads trained model & feature/segment order.  
- Gets a batch of restricted trials from Neo4j or your experiment DB.  
- For each **restricted** trial:

  1. Build `TrialConfig`.  
  2. Get `input_score` (e.g. SHAP) and `segment_score` (Potency Index or RV score from CRâ€‘002/3).  
  3. Run `mufs_search`.  
  4. If MUFS found:
     - Create `:MUFS` node.
     - Set `Trial.mpg_intuitive = true` + MUFS metadata.

Sketch:

```python
def run_mufs_batch():
    db = LAIZANeo4j(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)
    try:
        # 1. Load your model and orders (implementation-specific)
        engine = load_decision_engine()

        # 2. Fetch restricted trials
        trials = db.run("""
        MATCH (t:Trial)
        WHERE t.awareness_condition IN ["IU", "PU", "MIX"]
        RETURN t
        """)

        for rec in trials:
            t = rec["t"]
            trial_id = t["id"]

            cfg = build_trial_config_from_db(trial_id, db)  # user-defined

            input_score = compute_input_importance(trial_id, cfg)     # SHAP or heuristic
            segment_score = fetch_segment_potency(trial_id, db)       # from CR-003

            result = mufs_search(engine, cfg, input_score, segment_score)

            if result.exists:
                mufs_id = db.create_mufs(
                    trial_id,
                    awareness_condition=t["awareness_condition"],
                    input_keys=result.input_keys,
                    segment_ids=result.segment_ids,
                )
                mufs_type = (
                    "IU" if result.input_keys and not result.segment_ids
                    else "PU" if result.segment_ids and not result.input_keys
                    else "MIX"
                )
                db.mark_trial_intuition(
                    trial_id,
                    mufs_size=len(result.input_keys) + len(result.segment_ids),
                    has_mufs=True,
                    mufs_type=mufs_type,
                )
            else:
                db.mark_trial_intuition(
                    trial_id,
                    mufs_size=0,
                    has_mufs=False,
                    mufs_type="NONE",
                )
    finally:
        db.close()
```

Now you have a **systemâ€‘only MPGâ€‘Intuition dataset** like the one described in Section 6: MUFS incidence, trialâ€‘level intuition labels, linked to RV potency and, via `SegmentState`, to Noetic coherence.  [oai_citation:11â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 8. Noetic & Mirror Core hooks

With CRâ€‘001â€“3 + CRâ€‘004:

- For each **restricted** trial you now store:
  - `Trial.awareness_condition`
  - `Trial.mpg_intuitive` (boolean)
  - MUFS content (`:MUFS` + `input_keys` + `INCLUDES_SEGMENT`).
  - Segment Potency (`SegmentState.potency`, `SegmentState.coherence`).

Mirror Core / analysis can run queries like:

```cypher
// MUFS incidence vs coherence
MATCH (t:Trial {awareness_condition: "PU"})-[:HAS_MUFS]->(m:MUFS),
      (t)-[:USES_SEGMENT]->(s:Segment)-[:HAS_STATE]->(st:SegmentState)
WHERE st.rv = true
RETURN t.id, t.mpg_intuitive, m.size AS mufs_size, st.coherence, st.potency
ORDER BY st.coherence ASC;
```

This directly supports the **predictions in Section 6**:

- Restricted blocks yield more MUFS and more flips than full.  
- Trials marked as **MPGâ€‘Intuitive** (nonempty MUFS) coâ€‘occur with higher Noetic coherence and better calibration/accuracy under restriction.  [oai_citation:12â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 9. How to run CRâ€‘004 endâ€‘toâ€‘end

1. Ensure CRâ€‘001â€“3 are in place (segments, RV SHAP, Potency, SegmentState).  [oai_citation:13â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
2. Add/extend `:Trial` schema and create `:MUFS` constraint in Neo4j.  
3. Implement `DecisionEngine`, trial builders, and `mufs_search_demo.py` as above.  
4. Generate or load a batch of trials with **awareness_condition â‰  FULL**.  
5. Run:

   ```bash
   python scripts/mufs_search_demo.py
   ```

6. Inspect results:

   ```cypher
   MATCH (t:Trial)-[:HAS_MUFS]->(m:MUFS)
   RETURN t.id, t.awareness_condition, t.mpg_intuitive, m.size, m.input_keys
   ORDER BY t.id;
   ```

---

## 10. Acceptance criteria

CRâ€‘004 is complete when:

1. **MUFS search implemented**
   - For restricted trials, code can produce a candidate MUFS (subset of hidden inputs/segments) whose restoration flips the decision, and confirms its **minimality** under the greedy heuristic.  
   - The procedure respects the formal role of MUFS and MPGâ€‘Intuition (Defs. 7â€“8).  [oai_citation:14â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

2. **Neo4j data model updated**
   - `:Trial` nodes carry awareness, MUFS, and `mpg_intuitive` flags.
   - `:MUFS` nodes exist and link to trials and segments.

3. **MPGâ€‘Intuition label available**
   - `Trial.mpg_intuitive = true` for restricted trials with nonempty MUFS; false otherwise.  
   - You can query MUFS incidence by awareness condition and correlate with Potency / coherence.

4. **Consistency with theory & experimental strategy**
   - The implemented pipeline follows the **systemâ€‘only validation block** in Section 6 (full vs restricted, IU/PU, MUFS search, coherence linkage).  [oai_citation:15â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

5. **Documentation**
   - This text is saved as `docs/CR-004-MUFS-and-MPG-Intuition.md` alongside CRâ€‘001â€“3.

---

If youâ€™d like a CRâ€‘005 next, a natural followâ€‘up is **humanâ€‘inâ€‘theâ€‘loop integration**: mirroring the systemâ€™s MUFS/intuition markers with human trial data, awareness checks, and selfâ€‘report fields, so you can run the full program in Section 6 with real participants.  [oai_citation:16â€¡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)
