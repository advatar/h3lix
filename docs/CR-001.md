**Change Request: CR-001 – Minimal H3LIX MPG Prototype in Python + Neo4j**

---

## 1. Objective

Implement a **minimal runnable prototype** of the H3LIX / LAIZA Mirrored Profile Graph (MPG) using **Python + Neo4j**, including:

1. Creation of a **Layer-Type Graph** (level 0) in Neo4j.  
2. **Segmentation** of this graph in Python using NetworkX and application of the **Lift** operator to produce a level‑1 graph.  
3. A simple **Rogue Variable (RV)** detection pass over segments using Shapley-style contributions (synthetic or model-based).  [oai_citation:0‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

This is a vertical slice to validate the math in Sec. 4 (Defs. 1–4 and RV definitions) against a concrete implementation.  
The small graph should qualitatively resemble the examples in **Figures 1–3 (pages 10–12)**, where we see:  
- a base MPG structure (Fig. 1),  
- multiple segmentations under different filters (Fig. 2),  
- and tiny “contradiction” segments that become crucial metacognitive nodes (Fig. 3).  [oai_citation:1‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

## 2. Scope

**In scope**

- A single Python script (`mpg_demo.py`) that:
  - Connects to Neo4j and creates **constraints/indexes** for MPG nodes, segments, and evidence.
  - Inserts an example **level‑0 MPG** (5–8 nodes, 6–12 edges).
  - Reads the graph into **NetworkX**, runs **segment detection**, and writes **level‑1 segments** back to Neo4j as `:Segment` nodes.
  - Computes a toy **RV analysis** over segments and marks high‑impact segments as `rv = true` with a `rv_score` and `potency` property.

**Out of scope (for this CR)**

- Real somatic data ingestion or LAIZA session alignment.  
- Real SHAP integration with a trained ML model.  
- Full Noetic layer or MUFS experiments.

---

## 3. Technical Design

### 3.1 Neo4j schema (Layer-Type Graph)

Directly implements **Definition 1 – Layer-Type Graph** and Eq. (1) for confidence.  [oai_citation:2‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

**Node labels**

- `:MPGNode` – base-level nodes (traits, events, routines, etc.).
- `:Segment` – lifted segments (level‑1).
- `:Evidence` – evidence items attached to nodes or edges.

**Relationships**

- Node–node: `[:CAUSES]`, `[:TRIGGERS]`, `[:CONTRADICTS]`, etc. (subset of Σ_E).  
- Node/Segment → Evidence: `[:HAS_EVIDENCE]`.  
- Segment–segment and node–segment: same relation types as base graph.

**Constraints / indexes**

```cypher
CREATE CONSTRAINT mpgnode_id IF NOT EXISTS
FOR (n:MPGNode) REQUIRE n.id IS UNIQUE;

CREATE CONSTRAINT segment_id IF NOT EXISTS
FOR (s:Segment) REQUIRE s.id IS UNIQUE;

CREATE CONSTRAINT evidence_id IF NOT EXISTS
FOR (e:Evidence) REQUIRE e.id IS UNIQUE;

CREATE INDEX mpgnode_level IF NOT EXISTS
FOR (n:MPGNode) ON (n.level);
```

**Key properties**

For `:MPGNode` / `:Segment`:

- `id: string`
- `name: string`
- `layers: [string]` (e.g. `["Psychological"]`, `["History"]`)
- `valence: float` in [-1, 1]
- `intensity, recency, stability, importance, confidence: float` in [0, 1]
- `reasoning: string`
- `level: int` (0 for base, 1 for lifted)
- `rv: boolean` (for RV marking, default false)
- `rv_score: float` (absolute contribution)
- `potency: float` (simple Potency Index)

For relationships:

- `strength: float` (edge weight w(e))
- `confidence: float`
- `description: string`

For `:Evidence`:

- `id, description, source_type, pointer, snippet`
- `c, q, u, t: float` (support, quality, diversity, timeliness)
- Optional `created_at` timestamp

---

### 3.2 Python prototype script

Create `scripts/mpg_demo.py` with the following responsibilities:

1. Connect to Neo4j.  
2. Initialize schema.  
3. Insert a **toy Level‑0 MPG**.  
4. Load it as a NetworkX DiGraph.  
5. Run **segment detection** and **Lift** to Level‑1.  
6. Run **RV detection** over segments and write flags to Neo4j.

Below is a single-file implementation (runnable once `neo4j`, `networkx` are installed and Neo4j is up):

```python
"""
mpg_demo.py

Minimal H3LIX Mirrored Profile Graph prototype:
- Creates a level-0 MPG in Neo4j
- Segments graph in NetworkX and Lifts to level-1 segments
- Runs a simple Rogue Variable (RV) detection over segments
"""

from dataclasses import dataclass
from typing import List, Dict, Tuple
import uuid
import math

from neo4j import GraphDatabase
import networkx as nx


# === CONFIG ===

NEO4J_URI = "bolt://localhost:7687"
NEO4J_USER = "neo4j"
NEO4J_PASSWORD = "password"   # <-- change for your env


# === DOMAIN MODELS ===

@dataclass
class EvidenceItem:
    id: str
    description: str
    source_type: str
    pointer: str
    snippet: str
    c: float      # support
    q: float      # quality multiplier
    u: float      # diversity bonus
    t: float      # timeliness factor


def compute_confidence(evidence: List[EvidenceItem], alpha: float = 0.3) -> float:
    """
    Implements Eq. (1): S(x) = sum(c_i * q_i * u_i * t_i),
    Conf(x) = 1 - exp(-alpha * S(x)).
    """
    S = sum(e.c * e.q * e.u * e.t for e in evidence)
    return 1.0 - math.exp(-alpha * S)


# === NEO4J HELPERS ===

class MPGNeo4j:
    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def run(self, query: str, **params):
        with self.driver.session() as session:
            return list(session.run(query, **params))

    def init_schema(self):
        q = """
        CREATE CONSTRAINT mpgnode_id IF NOT EXISTS
        FOR (n:MPGNode) REQUIRE n.id IS UNIQUE;

        CREATE CONSTRAINT segment_id IF NOT EXISTS
        FOR (s:Segment) REQUIRE s.id IS UNIQUE;

        CREATE CONSTRAINT evidence_id IF NOT EXISTS
        FOR (e:Evidence) REQUIRE e.id IS UNIQUE;

        CREATE INDEX mpgnode_level IF NOT EXISTS
        FOR (n:MPGNode) ON (n.level);
        """
        with self.driver.session() as session:
            session.run(q)

    def clear_demo_data(self):
        # Clear only nodes with demo flag
        q = """
        MATCH (n)
        WHERE n.demo = true
        DETACH DELETE n
        """
        self.run(q)

    def create_node(
        self,
        name: str,
        layers: List[str],
        level: int = 0,
        valence: float = 0.0,
        intensity: float = 0.5,
        recency: float = 0.5,
        stability: float = 0.5,
        importance: float = 0.5,
        confidence: float = 0.5,
        reasoning: str = "",
    ) -> str:
        node_id = str(uuid.uuid4())
        q = """
        CREATE (n:MPGNode {
            id: $id,
            name: $name,
            layers: $layers,
            level: $level,
            valence: $valence,
            intensity: $intensity,
            recency: $recency,
            stability: $stability,
            importance: $importance,
            confidence: $confidence,
            reasoning: $reasoning,
            demo: true,
            rv: false
        })
        RETURN n.id AS id
        """
        res = self.run(
            q,
            id=node_id,
            name=name,
            layers=layers,
            level=level,
            valence=valence,
            intensity=intensity,
            recency=recency,
            stability=stability,
            importance=importance,
            confidence=confidence,
            reasoning=reasoning,
        )
        return res[0]["id"]

    def create_edge(
        self,
        src_id: str,
        dst_id: str,
        rel_type: str,
        strength: float = 0.5,
        confidence: float = 0.5,
        description: str = "",
    ) -> None:
        q = f"""
        MATCH (a:MPGNode {{id: $src_id}}),
              (b:MPGNode {{id: $dst_id}})
        CREATE (a)-[r:{rel_type} {{
            strength: $strength,
            confidence: $confidence,
            description: $description,
            demo: true
        }}]->(b)
        """
        self.run(
            q,
            src_id=src_id,
            dst_id=dst_id,
            strength=strength,
            confidence=confidence,
            description=description,
        )

    def load_level0_as_networkx(self) -> nx.DiGraph:
        G = nx.DiGraph()
        # Nodes
        q_nodes = """
        MATCH (n:MPGNode)
        WHERE n.demo = true AND n.level = 0
        RETURN n
        """
        for record in self.run(q_nodes):
            n = record["n"]
            G.add_node(n["id"], **dict(n))

        # Edges
        q_edges = """
        MATCH (a:MPGNode)-[r]->(b:MPGNode)
        WHERE a.demo = true AND b.demo = true AND a.level = 0 AND b.level = 0
        RETURN a.id AS src, b.id AS dst, type(r) AS rel_type, r
        """
        for record in self.run(q_edges):
            G.add_edge(
                record["src"],
                record["dst"],
                rel_type=record["rel_type"],
                **dict(record["r"]),
            )

        return G

    def create_segment_node(
        self,
        member_node_ids: List[str],
        level: int,
        agg_props: Dict[str, float],
        name: str = "",
    ) -> str:
        seg_id = str(uuid.uuid4())
        q = """
        CREATE (s:Segment {
            id: $id,
            name: $name,
            level: $level,
            members: $members,
            valence: $valence,
            intensity: $intensity,
            recency: $recency,
            stability: $stability,
            importance: $importance,
            confidence: $confidence,
            reasoning: $reasoning,
            demo: true,
            rv: false
        })
        RETURN s.id AS id
        """
        res = self.run(
            q,
            id=seg_id,
            name=name,
            level=level,
            members=member_node_ids,
            valence=agg_props["valence"],
            intensity=agg_props["intensity"],
            recency=agg_props["recency"],
            stability=agg_props["stability"],
            importance=agg_props["importance"],
            confidence=agg_props["confidence"],
            reasoning=agg_props["reasoning"],
        )
        return res[0]["id"]

    def create_segment_edge(
        self,
        src_seg_id: str,
        dst_seg_id: str,
        rel_type: str,
        strength: float,
        confidence: float,
        description: str,
    ) -> None:
        q = f"""
        MATCH (s:Segment {{id: $src_id}}),
              (t:Segment {{id: $dst_id}})
        CREATE (s)-[r:{rel_type} {{
            strength: $strength,
            confidence: $confidence,
            description: $description,
            demo: true
        }}]->(t)
        """
        self.run(
            q,
            src_id=src_seg_id,
            dst_id=dst_seg_id,
            strength=strength,
            confidence=confidence,
            description=description,
        )

    def mark_segment_as_rv(self, seg_id: str, rv_score: float, potency: float):
        q = """
        MATCH (s:Segment {id: $id})
        SET s.rv = true,
            s.rv_score = $rv_score,
            s.potency = $potency
        """
        self.run(q, id=seg_id, rv_score=rv_score, potency=potency)


# === STEP 1: INSERT TOY LEVEL-0 GRAPH ===

def seed_example_graph(db: MPGNeo4j):
    """
    Create a small graph loosely inspired by Fig. 1 and Fig. 3:
    - two contradictory segments
    - a few strong edges to drive segmentation
    """
    db.clear_demo_data()

    # Example nodes
    n_values = db.create_node(
        "Core values: autonomy",
        ["Psychological"],
        valence=0.8,
        intensity=0.7,
        reasoning="From interview: autonomy highly valued",
    )
    n_job = db.create_node(
        "Current job demands obedience",
        ["Professional"],
        valence=-0.3,
        intensity=0.6,
        reasoning="Job description & self-report",
    )
    n_coping = db.create_node(
        "Coping: suppress opinion at work",
        ["CopingRoutine"],
        valence=-0.6,
        intensity=0.8,
        reasoning="Self-report: often stays silent in meetings",
    )
    n_goal = db.create_node(
        "Goal: be seen as collaborative",
        ["Psychological"],
        valence=0.5,
        intensity=0.5,
    )
    n_stress = db.create_node(
        "Somatic: chronic tension",
        ["Somatic"],
        valence=-0.7,
        intensity=0.9,
    )

    # Example edges (some strong, some weak)
    db.create_edge(n_values, n_coping, "CONTRADICTS", strength=0.9,
                   description="Autonomy vs suppression at work")
    db.create_edge(n_job, n_coping, "CAUSES", strength=0.8)
    db.create_edge(n_coping, n_stress, "TRIGGERS", strength=0.7)
    db.create_edge(n_goal, n_coping, "MODERATES", strength=0.4)
    db.create_edge(n_values, n_goal, "ALIGNS", strength=0.6)


# === STEP 2: SEGMENTATION & LIFT ===

def segment_graph(G: nx.DiGraph, min_size: int = 2) -> List[List[str]]:
    """
    Simple segmentation: take strong edges (strength > 0.6) and
    compute weakly-connected components.
    Returns list of lists of node ids.
    """
    H = nx.DiGraph()
    for u, v, d in G.edges(data=True):
        if d.get("strength", 0) > 0.6:
            H.add_edge(u, v, **d)

    segments = []
    for comp in nx.weakly_connected_components(H):
        if len(comp) >= min_size:
            segments.append(list(comp))
    return segments


def aggregate_segment_props(G: nx.DiGraph, node_ids: List[str]) -> Dict[str, float]:
    """
    Aggregate node properties into segment-level metrics (mean).
    """
    vals = {k: [] for k in ["valence", "intensity", "recency", "stability", "importance", "confidence"]}
    for nid in node_ids:
        data = G.nodes[nid]
        for k in vals.keys():
            vals[k].append(float(data.get(k, 0.5)))

    agg = {k: (sum(v) / len(v) if v else 0.5) for k, v in vals.items()}
    agg["reasoning"] = f"Lifted segment of {len(node_ids)} nodes"
    return agg


def build_segment_edges(
    G: nx.DiGraph, segments: List[List[str]]
) -> List[Tuple[int, int, Dict]]:
    """
    Create edges between segments (Definition 3 and 4).
    For each pair of segments, if there are edges crossing from S to T,
    aggregate their strength & confidence.
    """
    seg_edges = []
    seg_index = {i: set(seg) for i, seg in enumerate(segments)}
    for i, S in seg_index.items():
        for j, T in seg_index.items():
            if i == j:
                continue
            strengths = []
            confidences = []
            rel_types = set()
            for u in S:
                for v in T:
                    if G.has_edge(u, v):
                        d = G.edges[u, v]
                        strengths.append(d.get("strength", 0.5))
                        confidences.append(d.get("confidence", 0.5))
                        rel_types.add(d.get("rel_type", "REL"))
            if strengths:
                seg_edges.append(
                    (
                        i,
                        j,
                        {
                            "strength": sum(strengths) / len(strengths),
                            "confidence": sum(confidences) / len(confidences),
                            "rel_type": list(rel_types)[0],  # pick first
                        },
                    )
                )
    return seg_edges


def lift_level0_to_level1(db: MPGNeo4j) -> List[str]:
    """
    Implements Definition 4 Lift(G^(0)) -> G^(1) for the demo graph.
    Returns list of segment ids created in Neo4j.
    """
    G = db.load_level0_as_networkx()
    segments = segment_graph(G)
    if not segments:
        print("No segments found; nothing to lift.")
        return []

    # Create segment nodes in Neo4j
    segment_ids: Dict[int, str] = {}
    for i, seg_nodes in enumerate(segments):
        agg = aggregate_segment_props(G, seg_nodes)
        seg_name = f"Segment {i}"
        seg_id = db.create_segment_node(seg_nodes, level=1, agg_props=agg, name=seg_name)
        segment_ids[i] = seg_id

    # Create segment edges
    seg_edges = build_segment_edges(G, segments)
    for i, j, d in seg_edges:
        db.create_segment_edge(
            segment_ids[i],
            segment_ids[j],
            d["rel_type"],
            strength=d["strength"],
            confidence=d["confidence"],
            description=f"Lifted from {len(segments[i])}x{len(segments[j])} crossing edges",
        )

    return list(segment_ids.values())


# === STEP 3: SIMPLE RV DETECTION OVER SEGMENTS ===

def detect_rogue_segments(db: MPGNeo4j):
    """
    Toy RV: treat each segment as a variable with a synthetic contribution score.
    In real use, contributions would come from SHAP values of a trained model (Sec. 4.2).
    """
    q = """
    MATCH (s:Segment)
    WHERE s.demo = true
    RETURN s.id AS id, s.importance AS importance, s.confidence AS confidence
    """
    records = db.run(q)
    if not records:
        print("No segments to analyze.")
        return

    # Simple contribution: |importance * confidence|
    scores = []
    for r in records:
        contribution = abs(float(r["importance"]) * float(r["confidence"]))
        scores.append((r["id"], contribution))

    # Compute mean and std as in Eq. (3)
    import statistics
    values = [c for _, c in scores]
    mean = statistics.fmean(values)
    std = statistics.pstdev(values)  # close enough for demo

    threshold = mean + 3 * std
    print(f"RV threshold = {threshold:.4f} (mean={mean:.4f}, std={std:.4f})")

    for seg_id, contrib in scores:
        if contrib >= threshold:
            # For demo, simple Potency Index = contrib (placeholder)
            potency = contrib
            db.mark_segment_as_rv(seg_id, rv_score=contrib, potency=potency)
            print(f"Segment {seg_id} marked as RV (score={contrib:.4f})")


# === MAIN ENTRYPOINT ===

def main():
    db = MPGNeo4j(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)
    try:
        db.init_schema()
        seed_example_graph(db)
        seg_ids = lift_level0_to_level1(db)
        print(f"Created {len(seg_ids)} level-1 segments.")
        detect_rogue_segments(db)
        print("Done.")
    finally:
        db.close()


if __name__ == "__main__":
    main()
```

---

## 4. Deployment / Migration

1. **Pre‑requisites**
   - Neo4j instance running (local or remote).
   - Python 3.10+ environment.
   - Install dependencies:
     ```bash
     pip install neo4j networkx
     ```

2. **Config**
   - Update `NEO4J_URI`, `NEO4J_USER`, `NEO4J_PASSWORD` at the top of `mpg_demo.py`.

3. **Run**
   ```bash
   python scripts/mpg_demo.py
   ```

4. **Inspect in Neo4j Browser**
   - `MATCH (n:MPGNode {demo: true}) RETURN n;`  
   - `MATCH (s:Segment {demo: true}) RETURN s;`  
   - `MATCH (s:Segment {rv: true}) RETURN s;`

---

## 5. Acceptance Criteria

This change request is complete when:

1. **Schema**
   - Constraints and indexes for `:MPGNode`, `:Segment`, and `:Evidence` exist in Neo4j.

2. **Example Level‑0 Graph**
   - Running `mpg_demo.py` creates ~5 level‑0 nodes and ~5–8 edges with `demo = true`.

3. **Lifted Level‑1 Segments**
   - At least one `:Segment` node is created at `level = 1` with `members` listing its child nodes.
   - Segment edges exist between segments where base-graph edges cross segment boundaries (in line with Definitions 2–4 and the segment illustration on *page 11, Fig. 2*).  [oai_citation:3‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

4. **RV Marking**
   - `detect_rogue_segments` computes mean and std of segment contributions, and if any contribution exceeds **mean + 3σ**, the corresponding segment gets:
     - `rv = true`
     - `rv_score` and `potency` properties populated.  
   - This follows Definition 6’s three‑sigma criterion for Rogue Variables (Sec. 4.2).  [oai_citation:4‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

5. **Documentation**
   - This CR text lives alongside the script in the repo (e.g., `docs/CR-001-MPG-Prototype.md`).

---

## 6. Risks / Limitations

- RV analysis here uses **synthetic contributions** (importance × confidence) rather than SHAP values from a real prediction model; this is intentional for a first vertical slice and aligns with the text’s recommendation to elevate structural patterns, not individual features, as analysis units.  [oai_citation:5‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  
- Segmentation is a **simple strength-based connected components** approach, whereas production use should consider more advanced community detection / flow-based segmentation as noted in the paper (e.g., multilevel partitioning, spectral methods).  [oai_citation:6‡Symbiotic_human_AI_architecture.pdf](sediment://file_000000000db071f49f637b00e8081106)  

---

If you’d like, the next change request can extend this prototype to:

- use **real SHAP values** from a trained model over LAIZA trial data, and  
- add a small **React / Neo4j Browser plugin-like visualization** that shows `G^(0)` + `G^(1)` and highlights segments marked as RVs similar to the visual style in **Figures 1–3**.
